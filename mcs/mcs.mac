#warning

| mcs.mac
| MQ2 initial version written by Fluffy
| Original Idea and Xylobot Script from Sym
|
| Uses built-in modified spell_routines.inc Written by Rusty~
| Uses built-in modified move.inc by beatnik007 (Who credits Mckorr) and revised and converted to MQ2Data by Terramantian
|
| Plugins used:
|          MQ2AutoSkills
|          MQ2MoveUtils
|          MQ2Twist
|
| Last Updated by Sym
| Last Updated: 03.05.2006 11:00 am
| Version 1.13
|
|----------------------------------------------------------------------------
|                                                                            
| -- Jan 5th
|  + Updated Gift of Mana to level 85
|  + Updated Watchhp to use group | groupm | grouph | groupc 
|
| -- Added cleric shield click use like da  (Aegis of Superior Divinity)
|
| -- Added GroupHeal checks via:
|    > groupheal on/off
|	 > groupheal spell <name>
|	 > groupheal threshold <hp%> eg 70
|	 > groupheal recast <time>  10 = 1s
|	
|    EXAMPLE: <cleric> 
|    > groupheal spell gheal
|    > groupheal threshold 70
|    > groupheal recast 3s
|    
|    EXAMPLE: <shammy> 
|    > groupheal spell ghot
|    > groupheal threshold 70
|    > groupheal recast 30s
|    
|                                                                            
|----------------------------------------------------------------------------

#include Spell_Routines.inc
#include pull.mac
#include raid.mac
#include NinjAdvLoot.mac
#include common\newbuy.inc
|#include taskinfo.inc
|#include ishmez.mac

#chat group
#chat tell
#chat raid 

#event OwnMasterDoChannel "You tell |${mcsChannelName}|:#*#, '#1#'"
#event OwnMasterDoGroup   "You tell your party, '#1#'"
#event RaidInvite "#1# invites you to join a raid."
#event GroupInvite "#1# invites you to join a group."
#event DoTell "#1# tells you, '#2#'"
#event DoTell "#1# told you, '#2#'"
#event DoChannel "#1# tells |${mcsChannelName}|:#*#, '#2#'"
#event DoGroup "#1# tells the group, '#2#'"
#event DoIRC "<#1#> #2#"
#event DoIRC "[#1#(msg)] #2#"
#event DoIRC "[(msg)#1#] #2#"
#event DoRaid "#1# tells the raid,  '#2#'" 
#event DoRaid "#1# tells the raid, '#2#'"
#event DoGuild "#1# tells the guild, '#2#'"
#event LocalEcho "[MQ2] mcs #1#"
#event GetChannel "Channels: #*#"
#event NoFollow "Need a target for stick.#*#"
#event NoStick "You are no longer sticking to anything#*#"
#event Zoned "#*#You have entered#*#"
#event Ding "You have gained a level! Welcome to level#*#"
#event AADing "You have gained an ability point!#*#"
#event LowDrink "You are low on drink.#*#"
#event LowFood "You are low on food.#*#"
#event OutFood "You are out of food.#*#"
#event OutDrink "You are out of drink.#*#"
#event OutFoodLowDrink "You are out of food and low on drink#*#"
#event OutDrinkLowFood "You are out of drink and low on food#*#"
#event LowFoodLowDrink "You are low on food and drink#*#"
#event OutFoodOutDrink "You are out of food and drink#*#"
#event NospellSet "No such spell set exists. Usage: /memspellset < index#*#"
#event WhereBound "You are bound in #1# at #*#"
#event eDotAnnounce "Your #1# spell has worn off.#*#"
#event MobDead "You gain#*# experience#*#"
#event MobDead "Your faction standing with#*#"
#event Slain "You have been slain#*#"
#event MezOff "#*#has been awakened by#*#"
#event QuitIRC "# Server Error: #*#"
#event OtherQuitIRC "* #1# quit IRC (#*#"
#event GoM1    "You have been granted a gift of mana!"
#event GoM2    "You have been granted a gift of radiant mana!"
#event GoM3    "You have been granted a gift of exquisite radiant mana!"
#event GoM4    "You have been granted a gift of amazing exquisite radiant mana!"
#event GoMOff  "Your gift of #*#mana fades."
#event RodUsed "You experience an elemental transvergence.#*#"
#event Camping "It will take about 5 more seconds to prepare your camp."
#event Locked  "It's locked and you're not holding the key.#*#"
#event LootError "#*#You may not loot that item from this corpse.#*#"
#event BattleRez "<#1#>#*#BattleRez [#2#]#*#".



Sub Main(string arg1,string arg2)
    /squelch /alias /mcs /echo mcs
    /squelch /im quit
    /declare cDebug int outer 0
    /declare noInterrupt int outer 0
    /declare mcsVersion outer
    /declare IsFollowing string outer NULL
	/declare mcsReAnchor int outer 0
    /declare mcsAnchorX string outer NULL
    /declare mcsAnchorY string outer NULL
    /declare mcsFacing float outer
    /declare mcsAnchorRun int outer 0
    /declare mcsKeyword string outer
    /declare mcsChannel string outer
    /declare mcsChannelName string outer
    /declare mcsChannelPassword string outer
    /declare AbortCast string outer
    /declare MaxRecasts int outer 3
    /declare GStatusAnnounce int outer 0
    /declare GStatusTimer int outer
    /declare mcsGStatusTimer timer outer
    /declare SwitchSpells int outer 1
    /declare ResendTells int outer 0
    /declare ResendGroup int outer 0
    /declare ResendIRC int outer 0
    /declare ResendRaid int outer 0
    /declare ResendGuild int outer 0
    /declare Verbosity int outer 0
    /declare UseDebugForNotify int outer 1
    /declare UseChatForNotify int outer 0
    /declare UseIRCForNotify int outer 1
    /declare SitAfterCast int outer 1
    /declare SitDelay int outer 5
    /declare YellWhenHit int outer 0
	/declare YellWhenHitTimer timer outer 0
    /declare GateWhenHit int outer 0
    /declare GateSpellName string outer
    /declare QuitWhenHit int outer 0
    /declare QuitWhenDead int outer 0
    /declare QuitGateThreshold int outer
    /declare UntargetFirst int outer 0
    /declare DoForage int outer 0
    /declare DotAnnounce int outer 0
    /declare UseNameToCast int outer 1
    /declare GroupChat int outer 0
    /declare ValidUsers string outer
    /declare DefaultChat string outer
    /declare MaxCombat int outer 20
    /declare CombatList[${MaxCombat}] string outer
    /declare CombatAction[${MaxCombat}] int outer
	/declare CombatOver[${MaxCombat}] string outer
    /declare CombatAssist string outer
	/declare MobList string outer
    /declare DoMez int outer 0
	/declare CheckForMezTimer timer outer
    /declare MezRadius int outer 0
    /declare MezSpell string outer
    /declare Sticking int outer 0
    /declare tRequestor string outer
    /declare PassiveCombat int outer 0
    /declare GroupMA string outer NULL
    /declare Canni int outer 0
    /declare CanniDelay int outer 6
    /declare CanniTimer timer outer 6s
    /declare CanniHP int outer
    /declare CanniMana int outer
    /declare CanniVHP int outer
    /declare CanniVMana int outer
    /declare CanniSpell string outer canni
	/declare CanniAA string outer canni
    /declare CombatCanni int outer 0
    /declare CastSuccess int outer 0
    /declare DoingRecast int outer 0
    /declare SpreadOutAfterFollow int outer 0
	/declare AutoAA int outer 0
	/declare AutoAATimer timer outer 0

	/declare GroupHealSpell string outer
	/declare GroupHealThresh int outer 0
	/declare GroupHealRecast int outer 0
	/declare GroupHealTimer timer outer 0
	/declare DoGroupHeal int outer 0

||----- CHAIN CASTING 
    /declare DoingChain int outer 0
    /declare ChainSpell string outer
	/declare ChainRecast int outer 0
	/declare ChainInitialPause int outer 0
	/declare ChainNextTime int outer 0
	/declare ChainTarget1 string outer NULL
	/declare ChainTarget2 string outer NULL
	/declare ChainTarget3 string outer NULL
	/declare ChainFailed  string outer
	/declare ChainStopOnExp int outer 1
	/declare ChainIsCH int outer 0
	/declare ChainListChID int outer 0

	/declare GetAddOff string outer NULL
    /declare DoingMez int outer 0
    /declare DownTimeTwist string outer NULL
    /declare MezBroke int outer 0
    /declare LootAllCorpses int outer 0
	/declare Looting bool outer FALSE
    /declare CombatRecast int outer 0
    /declare doOnZone string outer
    /declare AutoMemSetName string outer exp
    /declare AutoMem int outer 0
    /declare MemSpells int outer 0
    /declare AutoWaitRez int outer 1
	/declare AutoAccept int outer 0
    /declare AutoJoinGroup int outer 1
    /declare KeepPet int outer 0
    /declare Tanking int outer 0
    /declare QuietFoodDrink int outer 1
    /declare UseGuildChat int outer 0
    /declare UseRaidChat int outer 1
    /declare UseTells int outer 1
    /declare UseGroupChat int outer 1
    /declare UseIRCChat int outer 1
    /declare UseChannelChat int outer 1
    /declare WatchIRC int outer 0
    /declare WatchIRCName string outer NONE
    /declare WatchIRCIM string outer IM
    /declare WatchIRCIM2 string outer IM
    /declare IMPass string outer NOPASS

    /declare SpellFullName string outer
    /declare SpellTextBeforeCast string outer
    /declare SpellTextAfterCast string outer
    /declare SpellType string outer
    /declare SpellGem int outer
    /declare SpellID int outer
    /declare SpellDuration float outer
	/declare SpellRange float outer 1
	/declare SpellReady bool outer
	/declare SpellRangeCheck bool outer true
    /declare NeedToRecast int outer
    /declare WantToRecast int outer
    /declare Recast int outer
    /declare RecastIfResisted int outer
    /declare SpellList string outer
    /declare SpellText int outer 1
    /declare RecastList string outer
    /declare InCombat int outer 0
    /declare CombatCheck timer outer 2s
    /declare MobID int outer 0
	/declare MobIDLocked int outer 0
    /declare AnchorReturnEndCombat int outer 0
    /declare PetBeltSpell string outer
    /declare PetWeaponSpell string outer
    /declare PetMaskSpell string outer
    /declare CheckForRez int outer 0
    /declare DarbThreshold int outer 0
    /declare DarbGroupHealSpell string outer NULL
    /declare DarbSpell string outer NULL
	/declare DarbShield string outer NULL
    /declare DarbSpellReady int outer 0
	/declare DarbShieldReady int outer 0
    /declare UseAAHoT int outer 0
    /declare AAHoTName string outer NULL
    /declare HealAfterDarb int outer 0
    /declare UseDarb int outer 0
    /declare MidDarb int outer 0
	/declare DarbTimer timer outer 0
    /declare MoveBack int outer 0
    /declare MoveSide int outer 0
    /declare MoveDir int outer 0
    /declare PetSpellName string outer NULL
    /declare DotRecastList string outer
    /declare OffTank int outer 0
    /declare DoHarvest int outer 0
    /declare HarvestMana int outer 0
    /declare MeleeStick string outer 10 hold behindonce
	/declare MeleeOn int outer 0
    /declare AnchorLeashing int outer 0
    /declare LeashRange int outer 200
    /declare LDONMode int outer 0
    /declare LDONWho string outer

    /declare AssistType string outer
    /declare CasterMelee int outer 0
    /declare ScreenWidth int outer 1024
    /declare ScreenHeight int outer 768
    /declare Debug int outer 0
    /declare a int
    /declare DoSit int outer 0
    /declare SitTimer timer outer ${SitDelay}s

    /declare MyName string outer ${Me.Name.Lower}
    /declare WatchHPList string outer
    /declare OrigWatchHP string outer
    /declare BuffDurationFocus float outer 1.0
	/declare TankList string outer PAL|SHD|WAR
    /declare CasterList string outer CLR|DRU|ENC|MAG|NEC|SHM|WIZ|BST|PAL|RNG|SHD
    /declare MeleeList string outer BER|MNK|ROG|WAR|BRD|BST|PAL|RNG|SHD
    /declare HybridList string outer BRD|BST|PAL|RNG|SHD
	/declare AllClassList string outer BER|BRD|BST|CLR|DRU|ENC|MAG|MNK|NEC|PAL|RNG|ROG|SHD|SHM|WAR|WIZ
	/declare RezClassList string outer CLR|DRU|SHM
    /declare UseIRC int outer 0
    /declare IRCServer string outer NULL
    /declare IRCPort int outer 6667
    /declare IRCChannel string outer NULL
    /declare FoodSpell string outer
    /declare WaterSpell string outer
    /declare AutoTrade int outer 1
    /declare TradeClickWait timer outer
    /declare AutoPetHold int outer 0
    /declare LastZone int outer ${Zone.ID}
	/declare LastMeID int outer ${Me.ID}
    /declare ZTime timer outer 15
    /declare WatchHP int outer 1
    /declare GoMActive int outer 0
    /declare UseGoM int outer 0
    /declare GoMSpellName string outer NULL
    /declare GoMSpellPC70 string outer NULL
	/declare GoMSpellPC75 string outer NULL
	/declare GoMSpellPC80 string outer NULL
	/declare GoMSpellPC85 string outer NULL
	/declare GoMSpellNPC70 string outer NULL
	/declare GoMSpellNPC75 string outer NULL
	/declare GoMSpellNPC80 string outer NULL
	/declare GoMSpellNPC85 string outer NULL
	/declare UseModRod int outer 0
	/declare ModRodTimer timer outer 0
	/declare MezImmuneList string outer ^

	/declare UseOOC      int outer 0
	/declare UseOOCNow   int outer 0
	/declare OwnMaster   int outer 0
	/declare CureMax     int outer 0
	/declare CureSet string outer NULL
	/declare CureSetTimer timer outer 
	/declare ScriptSet   int outer 0
	/declare DoTimeCnt   int outer 0
	/declare DoTimeRef	 int outer 0
	/declare DoTimeRep   float outer 0
	/declare RaidPulseTimer timer outer 
	/declare LoreItemError int outer 0
	/declare DPSTimer  timer outer 1s
	/declare RndSayTimer timer outer 0
	/declare RndSayText string outer NULL
	/declare RndSayTarg int outer 0
	/declare TaskHud     int outer 0
	/declare HudStr		string outer 

	/declare mcsINI		string outer mcs.ini
    /varset mcsVersion          1.13
	/varset CanniAA Cannibalization

    /for a 1 to ${MaxCombat}
        /varset CombatList[${a}] NULL
        /varset CombatAction[${a}] 0
		/varset CombatOver[${a}] NULL
    /next a

|    /if (${Window[ChatWindow].Open} && !${Window[ChatWindow].Minimized}) /mqmin

	/if ( ${Macro.Params}>0 && ${arg1.Equal[new]} ) /call NewINI
	/if ( ${Macro.Params}>0 ) /varset mcsINI ${arg1}
	/if ( ${Macro.Params}>1 ) /varset MyName ${arg2.Lower}

    | Load in the INI Settings
    /call LoadINI
	/call SetupAdvLootVars

	/call RandomizeSeed
	/echo MCS Version: ${mcsVersion} Online
	
    /if (${UseIRC}) {
        /echo Connecting to IRC
        /call JoinIRC
        /call to_channel "-- Using IRC Channel ${IRCChannel} for communication"
    } else {
        /echo Attempting to join ${mcsChannel}
        /join ${mcsChannel}:${mcsChannelPassword}
        /delay 1s
    }
    /if (${IMPass.NotEqual[NOPASS]}) /im say identify ${IMPass}
    /doevents
	/call PullDefineVars
	|/call InitMez
	
    /call to_channel "-- MCS ready"
	/call ProcessRequest "${Me.Name}" "go auto"	
	|/call TaskInit
	
	|/notify ADLW_PLLWnd ADLW_PLLSetCmbo listselect 1
	|/notify ADLW_PLLWnd ADLW_PLLSetBtn leftmouseup                                         
	
    :Mainloop
        /if (${MacroQuest.GameState.NotEqual[INGAME]}) {
            /echo -- ${Time} -- NOT IN GAME, EXITING!!!
            /end
        }
        /doevents
		/call PullPulse
		/doevents
        /if (${WatchHP}) /call CheckWatchHPList
        /if (${GStatusAnnounce}) /call CheckGStatus
        /doevents
		/if (${Window[TradeWnd].Open} && ${TradeClickWait} <= 0) /call HandleOpenTradeWindow
		/doevents
        /if ((${CheckForRez} || ${AutoAccept}) && ${Window[ConfirmationDialogBox].Open}) /call TakeRez
		/if (${AutoAccept} && ${Window[LargeDialogWindow].Open}) /notify LargeDialogWindow LDW_YesButton leftmouseup
		/if (${AutoAccept} && ${Window[TaskSelectWnd].Open}) /notify TaskSelectWnd TSEL_AcceptButton leftmouseup		
        /if (${DoForage}) /call Forage
		/doevents
        /if (${AnchorLeashing} && ${mcsAnchorY.NotEqual[NULL]} && ${mcsAnchorX.NotEqual[NULL]} && ${Math.Distance[${Me.Y},${Me.X}:${mcsAnchorY},${mcsAnchorX}]} > ${LeashRange}) {
            /squelch /stick off
            /call MoveToLoc ${mcsAnchorY} ${mcsAnchorX}
        }
		/doevents
        /if (${InCombat}) {
            /if (${Tanking}) {
                /call DoCombatTanking
            } else {
                /call CheckCombatList
            }
        }
		/if (${Zone.ID}==213 || ${Zone.ID}==776) /call POWCheck
		/doevents
        /if (${mcsAnchorRun}) /call AnchorRunCheck
        /if (${WantToRecast}) /call CheckRecasts
		/if (${CureMax}!=0 && !${CureSetTimer}) /call CheckForCure
		/if (${RaidPulseTimer}==0) /call RaidPulse
		/doevents
        /if (${CheckForMezTimer}==0 && (${DoMez} || ${OffTank})) /call CheckForAdd
		|/if (${DoMez}) /call HandleMez
		/call BattleRez()
		/if (${PassiveCombat} && ${MobID} && ${Spawn[corpse id ${MobID}].ID} ) /varset MobID 0
		/if (${PassiveCombat} && !${MobID} && ${NetBots[${GroupMA}].Attacking} && ${NetBots[${GroupMA}].TargetID} && ${Me.Name.NotEqual[${GroupMA}]}) {
			/varset MobID ${NetBots[${GroupMA}].TargetID}
			|/echo PassiveCombat getting new target MobID = ${MobID}
			|/echo PASSIVE /if ( ${Spawn[pc ${GroupMA}].Distance} < 45 && ${Spawn[id ${MobID}].Distance} < 45 && ${Spawn[id ${MobID}].Type.Equal[NPC]} && ${NetBots[${GroupMA}].TargetHP} <= ${PassiveCombat} ) 
			/if ( ${Spawn[pc ${GroupMA}].Distance} < 45 && ${Spawn[id ${MobID}].Distance} < 45 && ${Spawn[id ${MobID}].Type.Equal[NPC]} && ${NetBots[${GroupMA}].TargetHP} <= ${PassiveCombat} && !${UseOOCNow}) {
				/echo PassiveCombat getting new target MobID = ${MobID} and calling go kill 
	            |/varset InCombat 1
	            /varset CombatAssist ${GroupMA}
				/call ProcessRequest "${GroupMA}" "go kill"
			} else {
				/varset MobID 0
			}
        }
		
		/doevents
        /if (${Canni} && (!${InCombat} || ${CombatCanni})) /call CanniCheck
		/if (${UseModRod} && !${InCombat}) /call ModRodCheck
		
		/if (${DoingChain} && ${Time.SecondsSinceMidnight}>=${ChainNextTime}) /call DoChain
		/doevents
        /if (${DoSit} && ${SitTimer} <= 0 && ${IsFollowing.Equal[Null]}) {
            /if (!${Me.Combat} && !${Me.Casting.ID}) {
                /if (!${Me.Sitting} && ${DoSit}) /sit
                /varset DoSit 0
           }
        }
		/doevents
        /if (${UseGoM} && ${GoMActive} && !${DoingChain}) {
			/echo GoM Fired - Target = ${Target}
			/if (${Target.ID} && ${Target.Type.Equal[npc]}) {
				/call CastSpellIfMemmed "${GoMSpellNPC${GoMActive}}" "blind" "once"
			} 
			/if (${Target.ID} && ${Target.Type.Equal[pc]}) {
				/call CastSpellIfMemmed "${GoMSpellPC${GoMActive}}" "blind" "once"
			}
            /varset GoMActive 0
        }

		/doevents
		/if (${UseOOCNow} && ${Me.PctMana}>90 ) {
			/varset UseOOCNow 0
			/call to_channel "-- I am FM -- Ready to go"
        }

		/doevents
		/if ( ${DoTimeRep} ) {
			/echo Frame ${DoTimeCnt} - ${Time.SecondsSinceMidnight}
			/varcalc DoTimeCnt ${DoTimeCnt} - 1
			/if ( ${DoTimeCnt}==0 ) {
				/varcalc DoTimeRep  (${Time.SecondsSinceMidnight} - ${DoTimeRef}) / 20.0
				/call to_channel "-- FPS: ${FPS} - mcs ${DoTimeRep} secs per loop"
				/varset DoTimeRep 0
			}
		}
		|/if (!${TaskTimer}) /call TaskUpdate
		/if (${NetBots} && ${Dps} && !${DPSTimer}) {
			|/echo /netnote ${Dps.Dps}  
			/varset HudStr 
			/if (${Me.Buff[Shared Perfected Camouflage].ID}) /varset HudStr ${HudStr} I
			/if (${Me.Buff[Group Perfected Silent Presence].ID}) /varset HudStr ${HudStr} I
			/if (${Me.Buff[Distract the Departed].ID}) /varset HudStr ${HudStr} U
			
			/if (${TaskHud}) {
				/netnote ${Dps.Dps} ${TaskMesg}
			} else {
				/netnote ${Dps.Dps} ${HudStr}
			}
			|/netnote ${Dps.Dps}
			|/netnote ${Time.SecondsSinceMidnight}
			/varset DPSTimer 10
		}
		/if (${AutoAA}) {
			/call AABalance
			/if (!${AutoAATimer}) /call AAPicker
			/call AABalance
		}
		/if (${RndSayText.NotEqual[NULL]} && !${RndSayTimer} ) /call DoRndSayText
		|/delay 1
		|/echo mcs loop
		
    /goto :Mainloop

/return

| -- In POW you must debuf any npc's before you can attack. 
Sub POWCheck

	/if (${Target.Type.Equal[NPC]} && ${Target.Beneficial.ID} && ${Melee.Combat}) {
		/if (${Cast.Ready[Entropy of Nature]} && ${Target.Beneficial.ID} && ${Target.Type.Equal[NPC]}) /casting "Entropy of Nature"	
		/if (${Cast.Ready[Nature's Entropy]} && ${Me.PctMana}>2 && ${Target.Beneficial.ID} && ${Target.Type.Equal[NPC]}) /casting "Nature's Entropy"
		/if (${Cast.Ready[Osh`vir`s Whisperwind Tunic]} && ${Target.Beneficial.ID} && ${Target.Type.Equal[NPC]}) /casting "Osh`vir`s Whisperwind Tunic"
		/if (${Cast.Ready[Fiercehand Shroud of the Focused]} && ${Target.Beneficial.ID} && ${Target.Type.Equal[NPC]}) /casting "Fiercehand Shroud of the Focused"
	}
	/return
/return



sub RandomizeSeed	
	/declare G int local 
	/declare a int local 0
	
	/varcalc G ${Me.CurrentHPs} % 7
    /for a 1 to ${G}
		/squelch /echo ${a} ${Math.Rand[10]}
    /next a
/return

sub DoRndSayText
	/if (${RndSayText.NotEqual[NULL]} && !${RndSayTimer} ) {
		/target id ${RndSayTarg}
		/say ${RndSayText}
		/varset RndSayText NULL
		/varset RndSayTarg 0
	}
/return



|| GoMActive = 70 , 75 , 80 , 85
|| SpellList will be spell to cast 

sub SetGOMSpells(string sList,string pc)
	/declare ShortName string
	/declare SpellName string
    /declare SpellLevel int	
	/declare index int

	/echo SetGOMSpells List = ( ${sList} )

	/for index 1 to 4
		/varset ShortName     ${sList.Arg[${index}," "].Lower}
		/varset SpellName     ${SpellInfo_${ShortName}.Token[1,","]}
		/varset SpellLevel	  ${Spell[${SpellName}].Level}

		/if (${SpellName.Equal[NULL]}) {
		} else /if (${SpellLevel} < 65) {
			/echo ${SpellName} to low for GOM
        } else /if (${SpellLevel} <= 70) {
			/varset GoMSpell${pc}70 ${ShortName}
			/echo   GoMSpell${pc}70 set to ${SpellName}
		} else /if (${SpellLevel} <= 75) {
			/varset GoMSpell${pc}75 ${ShortName}
			/echo   GoMSpell${pc}75 set to ${SpellName}
		} else /if (${SpellLevel} <= 80) {
			/varset GoMSpell${pc}80 ${ShortName}
			/echo   GoMSpell${pc}80 set to ${SpellName}
		} else /if (${SpellLevel} <= 85) {
			/varset GoMSpell${pc}85 ${ShortName}
			/echo   GoMSpell${pc}85 set to ${SpellName}
		}

	/next index
/return

|--- Call this in main loop to have fast battle rezing
sub BattleRez()
	/if ( !${Defined[BattleRezTM]} ) {
		/declare BattleRezTM timer outer 0s
		/declare BattleClearTM timer outer 0s
		/declare RezList string outer ^
		/declare RezClass int outer 0
		/if ( !${Defined[RezClassList]}) /declare RezClassList string CLR|DRU|SHM
		/if ( ${RezClassList.Find[${Me.Class.ShortName}]} ) /varset RezClass 1
	}
	/if ( ${RezClass}==0 || ${BattleRezTM} ) /return
	/varset  BattleRezTM 1s
	
	/if ( !${BattleClearTM}) /squelch /alert clear 5
	
	|--- Lets see if there are any bodies to rez ... after processing any events 
	/declare RezFilter string noalert 5 pccorpse zradius 75 radius 115
	/declare RezID int
	/declare RezName string

	/doevents
	/varset  RezID    /varset RezID ${Spawn[${RezFilter} class cleric].ID}
	/if ( !${RezID} ) /varset RezID ${Spawn[${RezFilter} class druid].ID}
	/if ( !${RezID} ) /varset RezID ${Spawn[${RezFilter} class shaman].ID}
	/if ( !${RezID} ) /varset RezID ${Spawn[${RezFilter} class enchanter].ID}
	/if ( !${RezID} ) /varset RezID ${Spawn[${RezFilter} class bard].ID}
	/if ( !${RezID} ) /varset RezID ${Spawn[${RezFilter}].ID}
	|/echo BattleRez RezID = ${RezID} BattleClearTM = [${BattleClearTM}]
	/if ( !${RezID} ) /return

	
	|--- Have a corpse - If we're in combat and body is alive - skip that corpse for a while.
	/if ( ${Me.CombatState.Equal[COMBAT]} && ${Spawn[pc ${Spawn[id ${RezID}].DisplayName}].ID} ) /goto :BattleRezSetTimer

	|--- Check to see if they are in our group or raid
	/varset RezName ${Spawn[id ${RezID}].Name.Arg[1,']}
	/echo RezName [${RezName}] : /if ( ${Spawn[group ${RezName}].ID}==0 && ${Spawn[raid ${RezName}].ID}==0 ) /return
	/if ( ${Spawn[group ${RezName}].ID}==0 && ${Spawn[raid ${RezName}].ID}==0 ) /goto :BattleRezSetTimer
	
	|-- Have a corpse to rez - are we able to ? 
	/declare CMD string NULL
	/if ( ${Cast.Ready[Call of the Wild]} ) /varset CMD "Call of the wild"
	/if ( ${Cast.Ready[Staff of Forbidden Rites]} && ${Me.CombatState.Equal[COMBAT]} ) /varset CMD "Staff of Forbidden Rites"
	/if ( ${Cast.Ready[Blessing of Resurrection]} ) /varset CMD "Blessing of Resurrection"
	/if ( ${Cast.Ready[Divine Resurrection]} && ${Spawn[id ${RezID}].Class.Name.Equal[Cleric]} && ${Me.CombatState.Equal[COMBAT]}) /varset CMD "Divine Resurrection"
	/if (${CMD.Length} < 5) /return
	
	|-- We have a target + spell so go ahead and do rez.
	/target id ${RezID}
	/delay 1
	/corpse
	/delay 1
	/casting ${CMD}
	/bc BattleRez [${Target.ID}] ${Target.DisplayName} with ${CMD}.

	|-- Use alert 5 to exclude bodies we don't want to try again right away.
	:BattleRezSetTimer
	/squelch /alert add 5 id ${RezID}
	/varset BattleClearTM 30s
/return

|--- Matches <FooBar> BattleRez [1375] DeadPC with "Blessing of Resurection".
#event BattleRez "<#1#>#*#BattleRez [#2#]#*#"

|--- When battle rez announced - hold off from rezing that body.
sub Event_BattleRez(string line,string Who,string RezID) 
	/if (!${Defined[RezClass]} || !${RezClass} || ${Me.CleanName.Equal[${Who}]} ) /return
	|/echo Event_BattleRez : RezID = ${RezID}
	/squelch /alert add 5 id ${RezID}
	/varset BattleClearTM 25s
/return


| Request: DoCure <SpellName> with <spell> from <Healer1> [Healer2]
sub CheckForCure
	/declare a int
	/declare b int
	/declare i int
    /declare c1 string
    /declare c2 string
    /declare c3 string
    /declare c4 string
	/declare c5 string
	/declare s string

	/varset CureSetTimer 1s

	/for a 1 to ${CureMax}
		/varset s  ${CureSet.Arg[${a},"~"]}
		/varset c1 ${s.Arg[1,"|"]}
		/varset c2 ${s.Arg[2,"|"]}
		/varset c3 ${s.Arg[3,"|"]}
		/varset c4 ${s.Arg[4,"|"]}

		|| -- /echo -- Check for cure of ${c1} with ${c2} from ${c3}

		/varset b ${Spell[${c1}].ID}
		/if ( ${b}==0 ) /goto :nextCheckForCure
		/if ( ${c3.Equal[NULL]} ) /goto :nextCheckForCure

		/if ((${c3.Equal[raid]} || ${c3.Equal[group]}) && ${Group.Members}) {
			/for i 1 to ${Group.Members} 
				/varset c5 ~ ${NetBots[${Group.Member[${i}].Name}].Buff} ~
				/if ( ${c5.Find[ ${b} ]} && ${Spawn[pc ${Group.Member[${i}].Name}].Distance} < 150) {
					/g I am casting ${c2} on ${Group.Member[${i}].Name}
					/call CastSpell ${c2} ${Group.Member[${i}].Name}
					/return
				}
			/next i
		}

		/if (${c3.Equal[raid]} && ${Raid.Members}) {
			/for i 1 to ${Raid.Members} 
				/varset c5 ~ ${NetBots[${Raid.Member[${i}].Name}].Buff} ~
				/if ( ${c5.Find[ ${b} ]} && ${Spawn[pc ${Raid.Member[${i}].Name}].Distance} < 150) {
					/g I am casting ${c2} on ${Raid.Member[${i}].Name}
					/call CastSpell ${c2} ${Raid.Member[${i}].Name}
					/return
				}
			/next i
		}

		/if ( ${Me.Buff[${c1}].ID} ) {
			/if ( ${c3.Equal[self]} ) {
				/call CastSpell ${c2} self
				/return
			}
			/if ( ${Spawn[pc ${c3}].Distance} > 0 && ${Spawn[pc ${c3}].Distance} < 150) {
				/tell ${c3} ${c2} 
				/varset CureSetTimer 20s
				/return
			}
			/if ( ${Spawn[pc ${c4}].Distance} > 0 && ${Spawn[pc ${c4}].Distance} < 150) {
				/tell ${c4} ${c2} 
				/varset CureSetTimer 20s
				/return
			}
		}

		:nextCheckForCure
	/next a
	/varset CureSetTimer 3s
/return



sub DoChain
	/declare ct int
	/declare late int
    /declare passes int 
	/varset passes 1


	/varset  ct ${ChainNextTime}
	/varcalc ChainNextTime ${ChainNextTime} + ${ChainRecast}
	/varcalc late ${Time.SecondsSinceMidnight} - ${ct}

|-  Check if we already have valid target
	:ChainGetTarget
	/if (${ChainTarget1.Equal[blind]}) /goto :ChainHasTarget
	/if (${ChainTarget1.Equal[assist]}) /goto :ChainSetAssist
	/if (!${Target.ID}) /goto :ChainSetTarget
	/if (${Target.Name.Equal[${ChainTarget1}]}) /goto :ChainHasTarget
	/if (${Target.Name.Equal[${ChainTarget2}]}) /goto :ChainHasTarget
	/if (${Target.Name.Equal[${ChainTarget3}]}) /goto :ChainHasTarget
|-  Target not set need to find best ....

	:ChainSetTarget
	/squelch /target pc ${ChainTarget1}
	/if (${Target.Name.Equal[${ChainTarget1}]}) /goto :ChainHasTarget
	/squelch /target pc ${ChainTarget2}
	/if (${Target.Name.Equal[${ChainTarget2}]}) /goto :ChainHasTarget
	/squelch /target pc ${ChainTarget3}
	/if (${Target.Name.Equal[${ChainTarget3}]}) /goto :ChainHasTarget

|-  No targets available were screwed 
	/echo No targets for chain , halting chain
	/varset DoingChain 0
	/if (${ChainFailed.NotEqual[NULL]}) /call CastSpell "${ChainFailed}" "blind"
	/return

    :ChainSetAssist
	/if (${MobID}==0) {
		/squelch /assist ${ChainTarget2}
		/doevents
		/delay 8
		/varset MobID ${Target.ID}
		/echo Seting chain to assist against MobID ${MobID} ${Target.Name}
	}

	/if ( ${Target.ID} != ${MobID} ) {
		/echo Targeting MobID ${MobID}
		/target id ${MobID}
		/delay 8
	}

	/echo Assisting mob [${Target.Name}] for its target
	/assist
	/delay 6
|	/if ( ${ChainListChID} != ${Target.ID} ) /varset ChainSpell al


	:ChainHasTarget
	/call CastSpell "${ChainSpell}" ${Target}
	/if (${CastSuccess}==0) {
		/doevents
		/varcalc passes ${passes}+1
		/if (${passes}>3) /return
		/goto :ChainGetTarget
	}

	/if (${ChainIsCH}) {
		/varset ChainSpell ch
		/varset ChainListChID ${Target.ID}
	}


	/if (${ChainTarget1.Equal[assist]}) {
		/target id ${MobID}
	}

/return

sub Event_Camping
	/bccmd quit
	/end
/return

sub Event_GotYell(string line, string who)
	/if (${DoMez} || ${OffTank}) {
		/varset GetAddOff ${who}
	}
/return

sub Event_GotHit(string line, string who,string hitwho)
	/if (${YellWhenHit} || ${GateWhenHit} || ${DoMez} || ${OffTank}) {
		|------  We are getting hit. Do we need to yell or gate? 
		/if (${hitwho.Equal[YOU]} && (${YellWhenHit} || ${GateWhenHit})) {
			/if (${YellWhenHit} && ${YellWhenHitTimer}==0) {
				/yell
				/call to_channel "-- GETTING HIT --"
				/varset YellWhenHitTimer 6s
			}
			/if (${GateWhenHit}) {
				/call to_channel "-- I got hit , gating ..."
				/call Cast "${GateSpellName}"
			}
		}
		|------  If we are add crew see who is getting hit
	
	}
/return


sub Event_GoM1
	/varset GoMActive 70
	/echo "-- GoM Active Level 65-70 (${GoMSpellName} )"
/return

sub Event_GoM2
	/varset GoMActive 75
	/echo "-- GoM Active Level 71-75 (${GoMSpellName} )"
/return

sub Event_GoM3
	/varset GoMActive 80
	/echo "-- GoM Active Level 76-80 (${GoMSpellName} )"
/return

sub Event_GoM4
	/varset GoMActive 85
	/echo "-- GoM Active Level 81-85 (${GoMSpellName} )"
/return


sub Event_GoMOff

    /varset GoMActive 0
|    /call to_channel "-- GoM Faded"
/return

sub Event_RodUsed
	/varset ModRodTimer 300s
/return

sub Event_Timer(Timer, OrigValue)

    /if (${Timer.Equal[ZTime]}) {
        /if (${Zone.ID} != ${LastZone}) /call Event_Zoned
		/if (${Me.ID} != ${LastMeID}) /call Event_Zoned
        /varset LastZone ${Zone.ID}
		/varset LastMeID ${Me.ID}
        /varset ${Timer} ${OrigValue}
    }

/return

sub Event_GroupInvite(string line, string Requestor)
    /declare isTrusted int

    | First check if allowed to command MCS
    /call isValidUser "${Requestor}"
    /varset isTrusted ${Macro.Return}

    /if (${isTrusted} && ${AutoJoinGroup}) {
        /call to_channel "-- Auto Joining Group with ${Requestor}"
        /keypress invite_follow
    }
/return

sub Event_RaidInvite(string line, string Requestor)
    /declare isTrusted int

    | First check if allowed to command MCS
    /call isValidUser "${Requestor}"
    /varset isTrusted ${Macro.Return}

    /if (${isTrusted} && ${AutoJoinGroup}) {
        /call to_channel "-- Auto Joining Raid with ${Requestor}"
        /raidaccept
    }
/return


sub Event_Slain

    /call to_channel "-- Something killed me"
    /if (${AutoMem} && ${AutoMemSetName.Length} > 0) /varset MemSpells 1
    /if (${AutoWaitRez}) /varset CheckForRez 1

    /if (${UseDarb}) {
        /varset UseDarb 0
        /call to_channel "-- Divine Arbitration *OFF*"
    }

    /if (${WatchHP}) {
        /varset WatchHP 0
        /call to_channel "-- Watch HP *OFF*"
    }

    /varset Canni 0
    /varset doOnZone

/return

sub CanniCheck

	/if (${Me.Invis}) {
		/varset CanniTimer 1s
		/return
	}
    /if (${Me.AltAbility[Frenzied Cannibalization]} > 0 && ${Me.CurrentHPs} > 4500 && ${Me.PctHPs} >= ${CanniVHP} && ${Me.PctMana} <= ${CanniVMana} && ${Me.AltAbilityReady[Frenzied Cannibalization]}) {
        /call Cast "Frenzied Cannibalization" alt
        /delay 5
    }


    /if (${Me.AltAbility[Cannibalization]} > 0 && ${Me.CurrentHPs} > 2000 && ${Me.PctHPs} >= ${CanniVHP} && ${Me.PctMana} <= ${CanniVMana} && ${Me.AltAbilityReady[Cannibalization]}) {
        /call Cast Cannibalization alt
        /delay 5
    }

    /if (${CanniTimer} > 0) /return

    /if (${Me.PctHPs} >= ${CanniHP} && ${Me.PctMana} <= ${CanniMana}) {
        /call CastSpell "${CanniSpell}" "blind"
        /varset CanniTimer ${CanniDelay}s
    }

/return

sub GetModRod
    /declare G int
	/if (${Me.Invis}) {
		/varset CanniTimer 30s
		/return
	}
	|/echo No ModRod -- Asking Mage.
	/if ( ${Me.Class.ShortName.Equal[MAG]}) {
		/call CastSpell rod self
	} else {
	    /for G 0 to ${Group}
        /if (${Group.Member[${G}].Class.ShortName.Equal[MAG]}) {
			|/echo Mage name = ${Group.Member[${G}].Name}
			/tell ${Group.Member[${G}].Name} rod please
			/varset G 6
		}
	    /next G
	}
/return

sub ModRodCheck

	/if (${Me.PctMana}<85 && ${ModRodTimer}==0) {
		|/echo Need mana - do we have a rod?
		/if ( ${Cursor.Name.Equal[Wand of Elemental Transvergence]} ) /autoinventory

		/if (!${FindItem[Wand of Elemental Transvergence].ID}) {
			/call GetModRod
			/varset ModRodTimer 30s
		} else {
			|/echo Found Rod - how many ticks?
			/varset ModRodTimer 30s
			/if (!${FindItem[Wand of Elemental Transvergence].Timer.Ticks}) {
				/echo Using Rod
				/call CastSpell "modrod" blind
				/if ( ${Cursor.Name.Equal[Wand of Elemental Transvergence]} ) /autoinventory
				/varset ModRodTimer 600s
			}
		}
	}
/return

sub Event_MezOff
    |/echo ******* MEZ BROKE ********
    /varset MezBroke 1
    /pet attack
    /if (${Me.Class.ShortName.Equal[BRD]}) {
        /if (${DownTimeTwist.NotEqual[NULL]}) /squelch /mcs twist ${DownTimeTwist}
    }
/return

sub Event_NoStick
    /varset Sticking 0
/return

sub Event_MobExp
	/bc <~ exp
	/call Event_MobDead
/return

sub Event_MobDead

|| -- Check MobID 

	/if (${Target.ID} && ${Target.PctHPs} && ${Target.Type.Equal[NPC]}) /return
	|/if (${MobID} && ${Spawn[${MobID}].Type.NotEqual[NPC]}) /return 

	/varset MobID 0
	
	|/echo Event_MobDead :: Entry
    /if (!${DoingMez}) {
		|/echo Event_MobDead :: !DoingMez
        /if (${InCombat}) {
			|/echo Event_MobDead :: InCombat
            /attack off
            /declare a int
            /for a 1 to ${MaxCombat}
                /varset CombatAction[${a}] 1
            /next a
            /varset MobID 0
            /if (${LootAllCorpses}) {
                /call LootNPC
                /varset mcsAnchorRun 1
            }
            /if (${AnchorReturnEndCombat}) /varset mcsAnchorRun 1

			/squelch /stick off
            /varset Sticking 0
            /if (${DownTimeTwist.NotEqual[NULL]}) /squelch /mcs twist ${DownTimeTwist}
			/call DoCombatOver
        } else {
            /if (${LootAllCorpses}) {
                /call LootNPC
                /varset mcsAnchorRun 1
            }
            /if (${AutoPetHold}) /squelch /pet hold
        }
		/varset MeleeOn 0
        /varset InCombat 0
        /varset DotRecastList

		/if (${LDONMode}) {
			|/echo Event_MobDead :: LDONMode -- will follow ${LDONWho}
			/call ProcessRequest "${LDONWho}" "follow"
			|/delay 5
			|/squelch /target clear
			|/call TargetPlayer "${LDONWho}"
			|/squelch /stick hold 15
			|/varset Sticking 1
		}

		/if (${DoingChain} && ${ChainStopOnExp}) /varset DoingChain 0

        /if (${KeepPet} && !${Me.Pet.ID} && ${PetSpellName.NotEqual[NULL]}) {
            /call CastSpell "${PetSpellName}" blind
		}

		/if (${UseOOC} && !${UseOOCNow} && ${Me.PctMana}<10 ) {
			/varset UseOOCNow 1
			/call to_channel "-- I am LOM using OOC Regen now"
			/call mySit
		}
    }
	/squelch /dps reset
/return

Sub AABalance
	/declare AAFree int local 0
	/declare AARate string local 0
	/if (${Me.Level}<51) /return
	/varset AAFree ${Window[AAWindow].Child[CurrentCount].Text}
	/varset AARate ${Window[AAWindow].Child[ExpCount].Text}
	/if (${AAFree}>=${Me.Level} && ${AARate.NotEqual[0%]}) /call NormalEXP
	/if (${AAFree}<${Me.Level} && ${AARate.NotEqual[100%]}) /call AAEXP
/return


Sub AAPicker(string Param)
	/declare a int local 1
	/declare b int local 3
	/declare AAFree int local 0
	/declare AARank string local
	/declare AAName string local
	/declare AACost int local
	/declare AAMinLevel int local
	/declare ListName string local
	/declare AATrainable string local
	/if (!${Defined[AALastPick]}) /declare AALastPick string outer NULL
	/if (${Pararm.Equal[now]}) /varset AALastPick NULL
	/varset AutoAATimer 6s	
	/varset AAFree ${Window[AAWindow].Child[CurrentCount].Text}
	/if (${AALastPick.Equal[${Me.Level}:${AAFree}]}) /return
	/varset AALastPick ${Me.Level}:${AAFree}	
	/if (!${Window[AAWindow].Child[CanPurchaseFilter].Checked}) {
		/nomodkey /notify AAWindow CanPurchaseFilter leftmouseup 
		/delay 10
	}
	:Loop
	/if (${Window[AAWindow].Child[List${b}].List[${a}].Length}) {
		/varset AAName ${Window[AAWindow].Child[List${b}].List[${a}, 1]} 
		/varset AARank ${Window[AAWindow].Child[List${b}].List[${a}, 2]} 
		/varset AACost ${Window[AAWindow].Child[List${b}].List[${a}, 3]} 
		
		/if (${AARank.Arg[1,"/"]}>0 && ${AARank.Arg[1,"/"]}<${AARank.Arg[2,"/"]} && ${AACost}<=${AAFree}) {
			|- We have a likely AA to purchase - lets see if we can. 
			/nomodkey /notify AAWindow AAW_Subwindows tabselect ${b}
			/nomodkey /notify AAWindow List${b} listselect ${a}
			/delay 2
			|- Try to purchase it
			/echo BuyAA AutoPicker Purchasing ${AAName} : Cost ${AACost} lv at ${AARank} - req lv ${AAMinLevel}
			/nomodkey /notify AAWindow TrainButton leftmouseup
			/delay 5
			/varset AutoAATimer 5				
		}
		/varcalc a ${a}+1
		/goto :Loop
	}
	/if (${b}>1) {
		/varcalc b ${b}-1
		/varset a 1
		/goto :Loop
	}
	/echo AAPickerLast ${AALastPick}
/return

sub NormalEXP
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/nomodkey /notify AAWindow LessExpButton leftmouseup 
	/popup SWITCHED TO NORMAL XP
/return

sub AAEXP
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/nomodkey /notify AAWindow MoreExpButton leftmouseup 
	/popup SWITCHED TO AA XP
/return


sub AnchorRunCheck
    /if (${mcsAnchorY.NotEqual[NULL]} && ${mcsAnchorX.NotEqual[NULL]}) {
        /call MoveToLoc ${mcsAnchorY} ${mcsAnchorX}
        /varset mcsAnchorRun 0
        /face nolook heading ${mcsFacing}
        /call to_channel "-- I am at my home anchor location"
    } else {
        /varset mcsAnchorRun 0
        /return
    }
/return

sub CheckGStatus
    /if ( ${GStatusAnnounce} && !${mcsGStatusTimer} ) {
        | If we arnt in group dont do it
        /if ( !${Group} ) {
            /varset mcsGStatusTimer ${GStatusTimer}m
            /return
        }
        /if ( ${Me.PctMana}==100 ) {
            /gsay "My current mana is: FOM(${Me.CurrentMana}/${Me.MaxMana})"
        } else {
            /gsay "My current mana is: ${Me.PctMana}m (${Me.CurrentMana}/${Me.MaxMana})"
        }
        | Reset the timer
        /varset mcsGStatusTimer ${GStatusTimer}m
    }
/return

sub Event_QuitIRC
    /call JoinIRC
/return

sub Event_LocalEcho(string line, string Request)
    /call ProcessRequest "${Me.CleanName}" "${Request}"
/return

Sub Event_OwnMasterDoChannel(string line, string Request)
    /if (${UseChannelChat} && ${OwnMaster}) /call ProcessRequest "${Me.CleanName}" "${Request}"
/return

Sub Event_OwnMasterDoGroup(string line, string Request)
    /if (${UseGroupChat} && ${OwnMaster}) /call ProcessRequest "${Me.CleanName}" "${Request}"
/return



Sub Event_DoGroup(string line, string Requestor, string Request)
    |/echo Line -${line}-
    |/echo Requestor -${Requestor}-
    |/echo Request -${Request}-

	/if (${Requestor.Left[1].Compare[ ]}<0) /varset Requestor ${Requestor.Right[-2].Left[-1]} 

    /declare isTrusted int

    | First check if allowed to command MCS
    /call isValidUser "${Requestor}"
    /varset isTrusted ${Macro.Return}

    | If they are not a Master then check if we should resend thier tells to channel
    /if (${ResendGroup} && !${isTrusted}) {
        /call chatty "${Requestor}" "the group," "${Request}"
        /return
    }

    | Added to stop above from not catching ! Trusted
    /if ( !${isTrusted} ) /return

    | They are Master lets check to see if it is a command
    /if (${UseGroupChat}) /call ProcessRequest "${Requestor}" "${Request}"

/return

Sub Event_DoIRC(string line, string Requestor, string Request)
    |/echo Line -${line}-
    |/echo Requestor -${Requestor}-
    |/echo Request -${Request}-
    /declare isTrusted int 1

    | If they are not a Master then check if we should resend thier tells to channel
    /if (${ResendIRC} && !${isTrusted}) {
        /call chatty "${Requestor}" "irc," "${Request}"
        /return
    }

    | Added to stop above from not catching ! Trusted
    /if ( !${isTrusted} ) /return

    | They are Master lets check to see if it is a command
    /if (${UseIRCChat}) /call ProcessRequest "${Requestor}" "${Request}"

/return


Sub Event_DoRaid(string line, string Requestor, string Request)
    | /echo Line -${line}-
    | /echo Requestor -${Requestor}-
    | /echo Request -${Request}-

	/if (${Requestor.Left[1].Compare[ ]}<0) /varset Requestor ${Requestor.Right[-2].Left[-1]} 

    /declare isTrusted int

    | First check if allowed to command MCS
    /call isValidUser "${Requestor}"
    /varset isTrusted ${Macro.Return}

    /if (${ResendRaid} && !${isTrusted}) {
        /call chatty "${Requestor}" "the raid," "${Request}"
        /return
    }

    | Added to stop above from not catching ! Trusted
    /if ( !${isTrusted} ) /return

    /if (${UseRaidChat}) /call ProcessRequest "${Requestor}" "${Request}"
/return

Sub Event_DoGuild(string line, string Requestor, string Request)
    |/echo Line -${line}-
    |/echo Requestor -${Requestor}-
    |/echo Request -${Request}-
    /declare isTrusted int

	/if (${Requestor.Left[1].Compare[ ]}<0) /varset Requestor ${Requestor.Right[-2].Left[-1]} 

    | First check if allowed to command MCS
    /call isValidUser "${Requestor}"
    /varset isTrusted ${Macro.Return}

    /if (${ResendGuild} && !${isTrusted}) {
        /call chatty "${Requestor}" "the guild," "${Request}"
        /return
    }

    | Added to stop above from not catching ! Trusted
    /if ( !${isTrusted} ) /return

    /if (${UseGuildChat}) /call ProcessRequest "${Requestor}" "${Request}"

/return

Sub Event_DoTell(string line, string Requestor, string Request)
    |/echo Line -${line}-
    |/echo Requestor -${Requestor}-
    |/echo Request -${Request}-
    /declare isTrusted int

	/if (${Requestor.Left[1].Compare[ ]}<0) /varset Requestor ${Requestor.Right[-2].Left[-1]} 

    | We dont care about your pet sending us tells
    /if ( ${Requestor.Equal[${Me.Pet.CleanName}]} ) /return

    | First check if allowed to command MCS
    /call isValidUser "${Requestor}"
    /varset isTrusted ${Macro.Return}

    | If they are not a Master then check if we should resend thier tells to channel
    /if (${ResendTells} && !${isTrusted}) {
	    |/if ( ${Requestor.Equal[${Me.Pet.CleanName}]} ) /return
		/if ( ${Requestor.Find[Merchant]} ) /return
		/if ( ${Spawn[npc ${Requestor}].ID} ) /return
		/if ( ${Request.Find[Master.]} ) /return
		
        /call chatty "${Requestor}" "me," "${Request}"
		/mqlog chatty "${Requestor}" "me," "${Request}"
		
		/beep
		/top
        /return
    }
	

    | Added to stop above from not catching ! Trusted
    /if ( !${isTrusted} ) /return

    | They are Master lets check to see if it is a command
    /if (${UseTells}) /call ProcessRequest "${Requestor}" "${Request}"
/return

Sub Event_DoChannel(string line, string Requestor, string Request)
    |/echo Line -${line}-
    |/echo Requestor -${Requestor}-
    |/echo Request -${Request}-

    | They are Master lets check to see if it is a command
	/if (${Requestor.Left[1].Compare[ ]}<0) /varset Requestor ${Requestor.Right[-2].Left[-1]} 
    /if (${UseChannelChat}) /call ProcessRequest "${Requestor}" "${Request}"
/return

sub ProcessRequest(Requestor, Request)
    /declare G int
    /declare a int
    /declare c1 string
    /declare c2 string
    /declare c3 string
    /declare c4 string
    /declare c5 string
    /declare c6 string
    /declare c7 string
    /declare c8 string
    /declare c9 string
    /declare c10 string

    /varset c1 ${Request.Arg[1," "].Lower}
    |/echo Requestor ${Requestor}
    |/echo Request ${Request}
    /varset tRequestor ${Requestor}


	| Requst : Pause 
	 /if ( ${c1.Equal[pause]} ) {
        /varset c2 ${Request.Arg[2," "]}
        /if ( ${c2} > 0 && ${c2} < 1000 ) {
			/delay ${c2}
		}
		/return
	}

    | Request: Group Join/Disband/List/Makeleader
    /if ( ${c1.Equal[group]} ) {
        | Get Second Parm
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( !${c2.Equal[NULL]} ) {
            | Join
            /if ( ${c2.Equal[add]} ) {
                | We are joining a group or Inviting
                /varset c3 ${Request.Arg[3," "].Lower}
                /if ( ${c3.Equal[NULL]} ) {
                    | No target me are joining or Inviting Master
                    /call TargetPlayer ${Requestor}
                    /keypress invite_follow
                    /call to_channel "-- Invited or Accepted group to ${Requestor}"
                    /return
                } else /if (${c3.Equal[all]}) {
					| add everyone in netbot channel.
					/for G 1 to ${NetBots.Counts}
						/varset c6 ${NetBots.Client.Arg[${G}," "]}
						/inv ${c6}
					/next G
                } else /if (${c3.Equal[ungrouped]} ) {
					| add everyone not grouped in netbot channel.
					/for G 1 to ${NetBots.Counts}
						/varset c6 ${NetBots.Client.Arg[${G}," "]}
						/if (!${NetBots[${c6}].Grouped}) {
							/echo Inviting ${c6} - ungrouped 
							/inv ${c6}
						}
					/next G
					
				} else {
                    | We need to invite someone
                    /invite ${c3}
                    /return
                }
            }
        }
		


        | Disband
        /if ( ${c2.Equal[disband]} ) {
            | We are going to disband group
            /keypress disband
            /return
        }

        | Makeleader
        /if ( ${c2.Equal[makeleader]} ) {
            | Lets make em leader
            /varset c3 ${Request.Arg[3," "].Lower}
            /if ( ${c3.Equal[NULL]} ) {
                | Make Requestor Leader
                /makeleader ${Requestor}
                /return
            } else {
                | Make Target Leader
                /makeleader ${c3}
                /return
            }
            /return
        }

        | List
        /if ( ${c2.Equal[list]} ) {
            /for G 0 to ${Group}
                /call to_channel "-- Group memeber ${G} - ${Group.Member[${G}].Name}"
            /next G
        /return
        }
    /return
    }

    | Request: Raid Join/Disband/Makeleader
    /if ( ${c1.Equal[raid]} ) {
        | Get Second Parm
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( !${c2.Equal[NULL]} ) {
            | Join
            /if ( ${c2.Equal[join]} ) {
                | We are joining a group or Inviting
                /varset c3 ${Request.Arg[3," "].Lower}
                /if ( ${c3.Equal[NULL]} ) {
                    | No target me are joining or Inviting Master
                    /call TargetPlayer "${Requestor}"
                    /raidaccept
                    /call to_channel "-- Invited or Accepted raid to ${Requestor}"
                    /return
                } else {
                    | We need to invite someone
                    /call TargetPlayer "${c3}"
                    /if ( ${Target.CleanName.Equal[NULL]} ) {
                        | Couldnt Target Them
                        /call to_channel "-- ${c3} isnt in zone to invite"
                        /return
                    } else {
                        /raidaccept
                        /return
                    }
                }
            }
        }

        | Disband
        /if ( ${c2.Equal[disband]} ) {
            | We are going to disband group
            /raiddis
            /return
        }

        | Makeleader
        /if ( ${c2.Equal[makeleader]} ) {
            | Lets make em leader
            /varset c3 ${Request.Arg[3," "].Lower}
            /if ( ${c3.Equal[NULL]} ) {
                | Make Requestor Leader
                /makeraidleader ${Requestor}
                /return
            } else {
                | Make Target Leader
                /makeraidleader ${c3}
                /return
            }
            /return
        }

    /return
    }


    | Request: assist [target] [target:pet] [mypet] [pet]
    /if ( ${c1.Equal[assist]} ) {
        /varset c2 ${Request.Arg[2," "]}
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
        /call AssistPlayer "${c2}"
        /return
    }

	| Request: SpellRangeCheck
	/if ( ${c1.Equal[spellrangecheck]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        |/echo ${c2}
        /if ( ${c2.Equal[on]} ) {
            /call to_channel "-- Spell range check on"
			/varset SpellRangeCheck 1
        }
        /if ( ${c2.Equal[off]} ) {
            /call to_channel "-- Spell range check off"
			/varset SpellRangeCheck 0
        }
	}


	| Request: UseOOC
	/if ( ${c1.Equal[useooc]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        |/echo ${c2}
        /if ( ${c2.Equal[on]} ) {
            /call to_channel "-- Will use OOC mana regen"
			/varset UseOOC 1
			/varset UseOOCNow 0
        }
        /if ( ${c2.Equal[off]} ) {
            /call to_channel "-- OOC Mana regen off"
			/varset UseOOC 0
			/varset UseOOCNow 0
        }
        /if ( ${c2.Equal[now]} ) {
            /call to_channel "-- Now using OOC Mana to regen"
			/varset UseOOC 1
			/varset UseOOCNow 1
			/call mySit
        }
	}

	| Request: GroupHeal
	/if ( ${c1.Equal[groupheal]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
		/varset c3 ${Request.Arg[3," "].Lower}

		/if ( ${c2.Equal[on]} ) {
			/call to_channel "-- Group Heal On"
			/varset DoGroupHeal 1
		}
		/if ( ${c2.Equal[off]} ) {
			/call to_channel "-- Group Heal Off"
			/varset DoGroupHeal 0
		}
		/if ( ${c2.Equal[spell]} ) {
			/varset GroupHealSpell ${c3}
			/call to_channel "-- Group Heal Spell = ${GroupHealSpell}"
		}
		/if ( ${c2.Equal[threshold]} ) {
			/varset GroupHealThresh ${c3}
			/call to_channel "-- Group Heal Threshold = ${GroupHealThresh}"
		}
		/if ( ${c2.Equal[recast]} ) {
			/varset GroupHealRecast ${c3}
			/call to_channel "-- Group Heal Recast = ${GroupHealRecast}"
		}
	}



    | Request: demem [gemslot]
    /if ( ${c1.Equal[demem]} ) {
        | Check to see what spell they want dememed
        /varset c2 ${Request.Arg[2," "]}
        /if ( ${c2} > 0 && ${c2} < 12 ) {
			/varset c3 ${Me.Gem[${c2}]}
            /if ( !${c3.Equal[NULL]} ) {
                /varset c3 ${Math.Abs[${c2}-1]}
                /notify CastSpellWnd CSPW_Spell${c3.Left[1]} rightmouseup
                /call to_channel "-- Spell ${c2} has been dememed"
                /return
            } else {
                /call to_channel "-- No spell in slot ${c2} already"
                /return
            }
        }
        /call to_channel "-- Unknown Spell #${c2}. Must be <1-9>"
        /return
    }

    | Request: list [memorized]
    /if ( ${c1.Equal[list]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[memorized]} ) {
            /call ListSpellsMem
        }
        /return
    }

    | Request: mem [set] [list]
    /if ( ${c1.Equal[mem]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /varset c4 ${Request.Arg[4," "].Lower}
        /if ( ${c2.Equal[set]} ) {
            /varset c3 ${Request.Arg[3," "]}
            /if ( ${c3.NotEqual[NULL]} ) {
                /call to_channel "-- Meming spell set ${c3}"
                /memspellset ${c3}
                /return
            }
            /return
        }

        /if ( ${c2.Equal[list]} ) {
            /call ListSpellsMem
            /return
        }

        /if (${Defined[SpellInfo_${c2}]}) {
            /if ( ${c3.Equal[NULL]} ) /varset c3 ${SpellInfo_${c2}.Token[4,","]}
            /call to_channel "-- Memorizing ${c2} (${SpellInfo_${c2}.Token[1,","]}) to gem slot ${c3}"
            /memspell ${c3} "${SpellInfo_${c2}.Token[1,","]}"
        }
    }

    | Request: Click yes/no/trade/center
    /if ( ${c1.Equal[click]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        |/echo ${c2}
        /if ( ${c2.Equal[target]} ) {
            /varset c3 ${Request.Arg[3," "].Lower}
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /call TargetPlayer "${c3}"
            /call to_channel "-- Clicking ${c3}"
            /click left target
        }
        /if ( ${c2.Equal[yes]} ) {
            /call to_channel "-- Clicking Yes"
            /notify ConfirmationDialogBox Yes_Button leftmouseup
        }
        /if ( ${c2.Equal[no]} ) {
            /call to_channel "-- Clicking No"
            /notify ConfirmationDialogBox No_Button leftmouseup
        }
        /if ( ${c2.Equal[trade]} ) {
            /call to_channel "-- Clicking Trade"
            /notify TradeWnd TRDW_Trade_Button LeftMouseUp
        }
        /if ( ${c2.Equal[zone]} ) {
            /call to_channel "-- Clicking Zone In"
            /declare ThisZone int ${Zone.ID}
            /declare ZCount int 0
            /delay 5s
            :WaitChange
                /varcalc ZCount ${ZCount} + 1
                /keypress use hold
                /keypress use
                /delay 15
                /if (${Zone.ID} != ${ThisZone} || ${ZCount} > 20) /goto :DidZone
            /goto :WaitChange

            :DidZone
        }
        /return
    }

    | Request: doanchor
    /if ( ${c1.Equal[doanchor]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[set]} ) {
            /call set_anchor
        }
        /if ( ${c2.Equal[clear]} ) {
            /call clear_anchor
        }
        /if ( ${c2.Equal[gohome]} ) {
            /call go_anchor
        }

        /if ( ${c2.Equal[leash]} ) {
            /varset c3 ${Request.Arg[3," "].Lower}
            /if (${c3.Equal[on]}) {
                /varset AnchorLeashing 1
                /call to_channel "-- Anchor Leashing *ON*"
            }
            /if (${c3.Equal[off]}) {
                /varset AnchorLeashing 0
                /call to_channel "-- Anchor Leashing *OFF*"
            }

            /if (${c3.Equal[range]}) {
                /varset c4 ${Request.Arg[4," "].Lower}
                /varset LeashRange ${c4}
                /call to_channel "-- Anchor Leash Range set to ${c4}"
            }
        }

        /if ( ${c2.Equal[endcombat]} ) {
            /varset c3 ${Request.Arg[3," "].Lower}
            /if (${c3.Equal[on]}) {
                /varset AnchorReturnEndCombat 1
                /call to_channel "-- AnchorReturn at End of Combat *ON*"
            }
            /if (${c3.Equal[off]}) {
                /varset AnchorReturnEndCombat 0
                /call to_channel "-- AnchorReturn at End of Combat *OFF*"
            }
        }
        /return
    }

    | Request: pull
    /if ( ${c1.Equal[pull]} ) {
		/call PullParse "${Request}"
		/return
	}
	
    | Request: cancel
    /if ( ${c1.Equal[cancel]} || ${c1.Equal[cancle]} ) {
        /call to_channel "-- Stopping All Actions"
        /varset mcsAnchorRun 0
        /keypress forward
        /if (${Me.Mount.ID}) /dismount
        /keypress duck
        /keypress duck
        /return
    }


    | Request: mypet
    /if ( ${c1.Equal[mypet]} ) /call to_channel "-- My pets name is ${Me.Pet.Name}"

    | Request: target
    /if ( ${c1.Equal[target]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
        /call TargetPlayer "${c2}"
        /return
    }
	/if ( ${c1.Equal[go]} || ${c1.Equal[cmdset]}) {
		/varset c2 ${Request.Arg[2," "].Lower}
|		/varset c3 ${Request.Arg[3," "].Lower}
|		/if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
		/if (${c2.NotEqual[NULL]}) /call LoadCommandSet "${c2}" "${Requestor}"
	}

    | Request: Pet attack/guardme/guardhere/follow/backoff/taunton/tauntoff/hold/sit/stand/feign/focus/nocast
    /if ( ${c1.Equal[pet]} ) {
        /if (!${Me.Pet.ID}) /return

        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[attack]} ) {
			/if (!${UseOOCNow}) {
				/call AssistPlayer "${Requestor}"
				/delay 3
				/call to_channel "-- Pet attacking ${Target.CleanName}"
				/stand
				/pet attack
			}
        }
        /if ( ${c2.Equal[guardme]} ) {
            /call to_channel "-- Pet guarding me"
            /pet guardme
        }
        /if ( ${c2.Equal[guardhere]} ) {
            /call to_channel "-- Pet guarding here"
            /pet guardhere
        }
        /if ( ${c2.Equal[follow]} ) {
            /call to_channel "-- Pet is now following me"
            /pet follow
        }
        /if ( ${c2.Equal[backoff]} ) {
            /call to_channel "-- Pet backing off"
            /pet back off
        }
        /if ( ${c2.Equal[taunton]} ) {
            /call to_channel "-- Pet is now taunting"
            /pet taunton
        }
        /if ( ${c2.Equal[tauntoff]} ) {
            /call to_channel "-- Pet is no longer taunting"
            /pet tauntoff
        }
        /if ( ${c2.Equal[hold]} ) {
            /call to_channel "-- Pet is now on hold"
            /pet back off
            /pet hold
        }
        /if ( ${c2.Equal[sit]} ) {
            /call to_channel "-- Pet is now sitting"
            /pet sit
        }
        /if ( ${c2.Equal[stand]} ) {
            /call to_channel "-- Pet is now standing"
            /pet stand
        }
        /if ( ${c2.Equal[feign]} ) {
            /call to_channel "-- Pet is now feigning"
            /pet feigning
        }
        /if ( ${c2.Equal[focus]} ) {
            /call to_channel "-- Pet is now focused on target"
            /pet focus
        }
        /if ( ${c2.Equal[nocast]} ) {
            /call to_channel "-- Pet will no longer cast spells"
            /pet nocast
        }
        /if ( ${c2.Equal[getlost]} ) {
            /call to_channel "-- Pet is now gone."
            /pet get lost
        }
        /return
    }


    | Request: Consent
    /if ( ${c1.Equal[consent]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[NULL]} ) {
            /call to_channel "-- Consenting ${Requestor}"
            /consent ${Requestor}
        }
        /if ( !${c2.Equal[NULL]} ) {
            /call to_channel "-- Consenting ${c2}"
            /consent ${c2}
        }
        /return
    }

	| Request: Stick
    /if ( ${c1.Equal[stick]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[NULL]} ) /varset c2 ${Requestor}
        |/echo Sticking to ${c2}'s target
        /call AssistPlayer "${c2}"
        /squelch /stick 10 hold
        /varset Sticking 1
		|/call to_channel "-- Sticking to ${Target.CleanName}"
    }

    | Request: Follow
    /if ( ${c1.Equal[follow]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /if ( !${c2.Equal[NULL]} ) {
            |/call to_channel "-- Following ${c2}"
            /varset IsFollowing ${c2}
        } else {
            |/call to_channel "-- Following ${Requestor}"
            /varset IsFollowing ${Requestor}
        }
        /if ( !${Me.Standing} ) /stand
		|/delay 6s ${Me.Casting.ID}
		/if ( ${Me.Name.NotEqual[${Requestor}]} ) {
	        /call TargetPlayer "${IsFollowing}"
			/squelch /afollow on
			|/delay 6s ${Me.Casting.ID}
			|/squelch /afollow unpause
	        /varset Sticking 1
			| - Override anchor - ELH
			/if ( ${mcsAnchorY.NotEqual[NULL]} || ${mcsAnchorX.NotEqual[NULL]} ) {
				/varset mcsReAnchor 1
				/call clear_anchor
			}
		}
        /return
    }

    | Request: help
    /if ( ${c1.Equal[help]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /call HelpSystem ${Request} ${c2}
        /return
    }

    | Request: Type
    /if ( ${c1.Equal[type]} ) {
|        /call to_channel "-- Executing ${Request.Right[${Math.Calc[${Request.Length}-5]}]}"
        /docommand ${Request.Right[${Math.Calc[${Request.Length}-5]}]}
        /return
    }


	/if ( ${c1.Equal[hotkeybank]} ) {
		/varset c3 ${Request.Arg[2," "].Lower}
		/if ( ${c3.NotEqual[NULL]} ) {
			/if ( ${c3} > 0 && ${c3} < 11 ) {
				/echo /keypress shift+${c3}
				/keypress shift+${c3}
				/delay 5
			}
		}
	}
	
    | Request: Hotkey <key> [bank]
    /if ( ${c1.Equal[hotkey]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
		/varset c3 ${Request.Arg[3," "].Lower}
		
		/if ( ${c3.NotEqual[NULL]} ) {
			/if ( ${c3} > 0 && ${c3} < 11 ) {
				/keypress shift+${c3}
				/delay 5
			}
		}
        /if ( ${c2.NotEqual[NULL]} ) {
			/if ( ${c2} > 0 && ${c2} < 11 ) {
				/keypress ${c2}
				/delay 5
			}
		}
        /return
    }


    | Request: DoCure <SpellName> with <spell> from <Healer1> [Healer2]
    /if ( ${c1.Equal[docure]} ) {
		/varset c2 ${Request.Arg[2," "].Lower}
		/varset c3 ${Request.Arg[3," "].Lower}

		/if ( ${c2.Equal[list]}) {
			/for a 1 to ${CureMax}
				/varset c3 ${CureSet.Arg[${a},"~"]}
				/varset c4 ${c3.Arg[1,"|"]}
				/varset c5 ${c3.Arg[2,"|"]}
				/varset c6 ${c3.Arg[3,"|"]}
				/varset c7 ${c3.Arg[4,"|"]}

				/if ( ${c7.Equal[NULL]} ) /varset c7 
				/if ( ${c6.Equal[NULL]} ) /varset c6
				/if ( ${c4.NotEqual[NULL]} )  /echo -- DoCure ${a} - ${c4} WITH ${c5} FROM ${c6} ${c7}
			/next a
			/return
		}

		/if ( ${c2.Equal[del]} && ${c3.Equal[all]} ) {
			/varset CureSet 
			/varset CureMax 0
			/return
		}

		/if ( ${c2.Equal[del]} ) {
			/varset c5
			/for a 1 to ${CureMax}
				/varset c4 ${CureSet.Arg[${a},"~"]}
				/if ( ${c3.NotEqual[${a}]} ) /varset c5 ${c5}${c4}~
			/next a
			/varset CureSet ${c5}
			/varset CureMax ${CureSet.Count["~"]}
			/return
		}

		/varset c4 ${Request.Arg[4," "].Lower}
		/varset c5 ${Request.Arg[5," "].Lower}
		/varset c6 ${Request.Arg[6," "].Lower}
		/varset c7 ${Request.Arg[7," "].Lower}
		/varset c8 ${Request.Arg[8," "].Lower}
		/varset c9 ${Request.Arg[9," "].Lower}

		/if ( ${c3.Equal[with]} && ${c5.Equal[from]} ) /varset c1 ${c2}|${c4}|${c6}|${c7}
		/if ( ${c4.Equal[with]} && ${c6.Equal[from]} ) /varset c1 ${c2} ${c3}|${c5}|${c7}|${c8}
		/if ( ${c5.Equal[with]} && ${c7.Equal[from]} ) /varset c1 ${c2} ${c3} ${c4}|${c6}|${c8}|${c9}
		/if ( ${c6.Equal[with]} && ${c8.Equal[from]} ) /varset c1 ${c2} ${c3} ${c4} ${c5}|${c7}|${c9}

		| -- catch syntax error 
		/if ( ${c1.Equal[docure]} || ${c2.Equal[NULL]} ) {
			/call to_channel "syntax is: DOCURE <spell name> WITH <spell> FROM <healer1>  [healer2]"
			/return
		}

		/if ( ${CureSet.Equal[NULL]} ) /varset CureSet
		/varset CureSet ${CureSet}${c1}~
		/varset CureMax ${CureSet.Count["~"]}

        /return
    }




    | Request: user add NAME/delete NAME/list/write/reset
    /if ( ${c1.Equal[user]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[list]} ) {
            /call to_channel "-- Valid user list: ${Ini[${mcsINI},${MyName}-configuration,userlist]}"
        }
        /return
    }

    | Request: gstatus on/off/value
    /if ( ${c1.Equal[gstatus]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset GStatusAnnounce 1
            /call to_channel "-- Gstatus announcing every ${GStatusTimer} minutes"
        } else /if ( ${c2.Equal[off]} ) {
            /varset GStatusAnnounce 0
            /call to_channel "-- Gstatus off"
        } else /if  ( ${c2.Equal[info]} ) {
            /varset GStatusTimer ${c2}
            /call to_channel "-- Gstatus announcing every ${GStatusTimer} minutes"
            /varset mcsGStatusTimer ${GStatusTimer}m
        } else {
            /if (${Me.PctMana} > 99) {
                /g fom
            } else {
                /g ${Me.PctMana}m
            }
        }
        /return
    }

    | Request: gstatus on/off/value
    /if ( ${c1.Equal[istatus]} ) {
        /if (${Me.PctMana} > 99) {
            /i say fom
        } else {
            /i say ${Me.PctMana}m
        }
        /return
    }

    | Request: Reload
    /if ( ${c1.Equal[reload]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[now]} ) {
            /call to_channel "-- MCS Reloading"
            /squelch /mac mcs
            /return
        }
        /if ( ${c2.Equal[ini]} ) {
            /call to_channel "-- Reloading INI"
            /call LoadINI
            /return
        }
    }

    | Request: watchirc
    /if ( ${c1.Equal[watchirc]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset WatchIRC 1
            /call to_channel "-- WatchIRC On"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset WatchIRC 0
            /call to_channel "-- WatchIRC Off"
        }
    }

    | Request: forage
    /if ( ${c1.Equal[forage]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset DoForage 1
            /call to_channel "-- Forage On"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset DoForage 0
            /call to_channel "-- Forage Off"
        }
        /if ( ${c2.Equal[once]} ) {
            /call to_channel "-- Foraging Once"
            /call Forage
        }
        /return
    }

    | Request: wherebound
    /if ( ${c1.Equal[wherebound]} ) /charinfo


    | Request: Version
    /if ( ${c1.Equal[version]} ) /call to_channel "-- MQ2 MCS v${mcsVersion}"

    | Request: Xp
    /if ( ${c1.Equal[xp]} ) /call to_channel "-- Experience: (${Me.PctExp}%)"

    | Request: AAXp
    /if ( ${c1.Equal[aaxp]} ) /call to_channel "-- Alternate Experience: (${Me.PctAAExp}%)"

    | Request: Stopfollow
    /if ( ${c1.Equal[stopfollow]} || ${c1.Equal[stop]}) {
		/if (${AdvPath.Following}) /squelch /afollow off
        /squelch /stick off
        /varset Sticking 0
        /if (${IsFollowing.NotEqual[Null]}) /call to_channel "-- No Longer Following ${IsFollowing}"
        /varset IsFollowing NULL
        /if (${SpreadOutAfterFollow}) /call SpreadOut
		| - ELH 2
		/if (${mcsReAnchor}) {
			/varset mcsReAnchor 0
			/call set_anchor
		}
		/if (${UseOOCNow}) /call mySit

        /return
    }

    | Request: Camp
    /if ( ${c1.Equal[camp]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset WatchHP 0
        /varset WantToRecast 0
        /varset Canni 0
        /squelch /twist off
        /if ( ${c2.Equal[desktop]} ) {
            /call to_channel "-- Camping to Desktop use the stand Request to abort!"
            /if ( ${Me.Mount.ID} ) /dismount
            /camp desktop
        } else /if ( ${c2.Equal[server]} ) {
            /call to_channel "-- Camping to Server Select use the stand Request to abort!"
            /if ( ${Me.Mount.ID} ) /dismount
            /camp server
        } else {
            /call to_channel "-- Camping to Character Select use the stand Request to abort!"
            /if ( ${Me.Mount.ID} ) /dismount
            /camp
        }
        /return
    }

    | Request: Target's Hitpoints
    /if ( ${c1.Equal[targethp]} ) {
        /if ( !${Target.ID} ) {
            /call to_channel "-- No current target selected"
            /return
        }
        /call to_channel "-- ${Target.CleanName} current health is: ${Target.PctHPs}"
        /return
    }

    | Request: dohorse [mount]/[dismount]
    /if ( ${c1.Equal[dohorse]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[mount]} ) {
            /call to_channel "-- Mounting Horse/Drogmor"
            /call CastSpell horse blind
            /delay 4s
            /varset SitDelay 0
            /varset SitAfterCast 0
        }
        /if ( ${c2.Equal[dismount]} ) {
            /call to_channel "-- Dismount Horse/Drogmor and resitting SitDelay and SitAfterCast"
            /dismount
        }
        /return
    }

    | Request: ResendTells [on]/[off]
    /if ( ${c1.Equal[ResendTells]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /call to_channel "-- Now resending all tells to channel"
            /varset ResendTells 1
        }
        /if ( ${c2.Equal[off]} ) {
            /call to_channel "-- No longer resending all tells to channel"
            /varset ResendTells 0
        }
        /return
    }


    | Request: DotAnnounce [on]/[off]
    /if ( ${c1.Equal[dotannounce]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /call to_channel "-- Now resending all spell wear off messages to channel"
            /varset DotAnnounce 1
        }
        /if ( ${c2.Equal[off]} ) {
            /call to_channel "-- No longer resending all spell wear off messages to channel"
            /varset DotAnnounce 0
        }
        /return
    }

	| Request: SpellText
    /if ( ${c1.Equal[spelltext]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /call to_channel "-- Pre/Post SpellText now *ON*"
            /varset SpellText 1
        }
        /if ( ${c2.Equal[off]} ) {
            /call to_channel "-- Pre/Post SpellText now *OFF*"
            /varset SpellText 0
        }
        /return
    }

    | Request: untarget
    /if ( ${c1.Equal[untarget]} ) {
        /squelch /keypress ESC
        /return
    }


    | Request: mana
    /if ( ${c1.Equal[mana]} ) {
        /if ( ${Me.PctMana}==100 ) {
            /call to_channel "-- My current mana is: FOM (${Me.CurrentMana}/${Me.MaxMana})"
        } else {
            /call to_channel "-- My current mana is: ${Me.PctMana}m (${Me.CurrentMana}/${Me.MaxMana})"
        }
        /return
    }

    | Request: hp
    /if ( ${c1.Equal[hp]} ) {
        /call to_channel "-- My current health is: ${Me.PctHPs}% (${Me.MaxHPs})"
        /return
    }

    | Request: Sit down
    /if ( ${c1.Equal[sit]} || ${c1.Equal[med]}  ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[now]}) /sit
        /varset DoSit 1
        /return
    }

    | Request: Stand
    /if ( ${c1.Equal[stand]} ) {
        /if ( !${Me.Standing} ) /stand
        /return
    }

    | Request: Tell
|    /if ( ${c1.Equal[tell]} ) {
|        /tell ${Request.Right[${Math.Calc[${Request.Length}-5]}]}
|        /return
|    }

    | Request: Group Say
|    /if ( ${c1.Equal[gsay]} ) {
|        /gsay ${Request.Right[${Math.Calc[${Request.Length}-5]}]}
|        /return
|    }

    | Request: Say
|    /if ( ${c1.Equal[say]} ) {
|        /say ${Request.Right[${Math.Calc[${Request.Length}-4]}]}
|        /return
|    }

    | Request: IRC Say
    /if ( ${c1.Equal[isay]} ) {
        /i say ${Request.Right[${Math.Calc[${Request.Length}-5]}]}
        /return
    }

    | Request: Guild
|    /if ( ${c1.Equal[guild]} ) {
|        /guildsay ${Request.Right[${Math.Calc[${Request.Length}-6]}]}
|        /return
|    }

	| Request: Restock
    /if ( ${c1.Equal[restock]} && ${Me.Class.ShortName.Equal[MAG]}) {
        /declare x int
        /for x 1 to 2
            /if (${FoodSpell.Length} > 0 ) /call CastSpell "${FoodSpell}" "blind"
            /delay 3s
            /if (${WaterSpell.Length} > 0 ) /call CastSpell "${WaterSpell}" "blind"
            /delay 3s
        /next x
        /varset c2 ${Request.Token[2," "].Lower}
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}

        /call TargetPlayer ${c2}
        /delay 2s
        /call to_channel "-- Giving Food and Water to ${Target.CleanName}"

        :GetGiveRange
        /if (${Target.Distance} > 15) {
            /squelch /stick 10 hold
            /delay 1s
            /if (${Target.Distance} > 15) /goto :GetGiveRange
        }

        /squelch /stick off

        /for x 1 to 5
            /if (${Target.ID} != ${Me.ID}) {
                /click left target
            } else {
                /autoinv
            }
            /delay 1s
        /next x

        /notify TradeWnd TRDW_Trade_Button LeftMouseUp

    }

	| Request: jump
	/if ( ${c1.Equal[jump]} ) {
		/keypress JUMP
		/return
	}

	| Request: autotrade
    /if ( ${c1.Equal[autotrade]} ) {
        /varset c2 ${Request.Token[2," "].Lower}

        /if (${c2.Equal[on]}) {
            /call to_channel "-- Auto Trade *ON*"
            /varset AutoTrade 1
            /return
        }
        /if (${c2.Equal[off]}) {
            /call to_channel "-- Auto Trade *OFF*"
            /varset AutoTrade 0
            /return
        }
    }

	| Request: cast
    /if ( ${c1.Equal[cast]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /varset c4 ${Request.Arg[4," "].Lower}
        /if (${c2.Equal[NULL]}) /return
        /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}

        /if (${c3.Equal[once]}) {
            /varset c3 ${Requestor}
            /varset c4 once
        }
        /if (${c3.Equal[group]}) {
            /for G 1 to ${Group}
                /call CastSpell "${c2}" "${Group.Member[${G}].CleanName}" "${c4}"
            /next G
            /call CastSpell "${c2}" "self" "${c4}"
            /return
        }
        /if (${c3.Equal[grouppet]}) {
            /for G 1 to ${Group}
                /if (${Group.Member[${G}].Pet.ID}) /call CastSpell "${c2}" "${Group.Member[${G}]}:pet" "${c4}"
            /next G
            /if (${Me.Pet.ID}) /call CastSpell "${c2}" "pet" "${c4}"
            /return
        }
        /if (${c3.Equal[groupc]}) {
            /for G 1 to ${Group}
                /if (${CasterList.Find[${Group.Member[${G}].Class.ShortName}]}) /call CastSpell "${c2}" "${Group.Member[${G}].CleanName}" "${c4}"
            /next G
            /if (${CasterList.Find[${Me.Class.ShortName}]}) /call CastSpell "${c2}" "self" "${c4}"
            /return
        }
        /if (${c3.Equal[groupm]}) {
            /for G 1 to ${Group}
                /if (${MeleeList.Find[${Group.Member[${G}].Class.ShortName}]}) /call CastSpell "${c2}" "${Group.Member[${G}].CleanName}" "${c4}"
            /next G
            /if (${MeleeList.Find[${Me.Class.ShortName}]}) /call CastSpell "${c2}" "self" "${c4}"
            /return
        }
        /if (${c3.Equal[grouph]}) {
            /for G 1 to ${Group}
                /if (${HybridList.Find[${Group.Member[${G}].Class.ShortName}]}) /call CastSpell "${c2}" "${Group.Member[${G}].CleanName}" "${c4}"
            /next G
            /if (${HybridList.Find[${Me.Class.ShortName}]}) /call CastSpell "${c2}" "self" "${c4}"
            /return
        }

        /call CastSpell "${c2}" "${c3}" "${c4}"
    }

	| Request: quietfooddrink
    /if ( ${c1.Equal[quietfooddrink]} ) {
        /varset c2 ${Request.Token[2," "].Lower}

        /if (${c2.Equal[on]}) {
            /call to_channel "-- Quiet Food/Drink *ON*"
            /varset QuietFoodDrink 1
            /return
        }
        /if (${c2.Equal[off]}) {
            /call to_channel "-- Quiet Food/Drink *OFF*"
            /varset QuietFoodDrink 1
            /return
        }
    }

	| Request: usegom
    /if ( ${c1.Equal[usegom]} ) {
        /varset c2 ${Request.Token[2," "].Lower}
        /varset c3 ${Request.Token[3," "].Lower}

        /if (${c2.Equal[on]}) {
            /call to_channel "-- Use GoM *ON*"
            /varset UseGoM 1
            /return
        }
        /if (${c2.Equal[off]}) {
            /call to_channel "-- Use GoM *OFF*"
            /varset UseGoM 0
            /return
        }
        /if (${c2.Equal[npc]}) {
			/call SetGOMSpells "${Request.Right[${Math.Calc[${Request.Length}-11]}]}" "NPC"
|            /call to_channel "-- Use GoM Spell is ${GoMSpellNPC}"
            /return
        }
        /if (${c2.Equal[pc]}) {
			/call SetGOMSpells "${Request.Right[${Math.Calc[${Request.Length}-10]}]}" "PC"
|			/varset GoMSpellPC ${Request.Right[${Math.Calc[${Request.Length}-10]}]}
|            /call to_channel "-- Use GoM Spell List is (${GoMSpellPC})"
            /return
        }

    }

	| Request: watchhp
    /if ( ${c1.Equal[watchhp]} ) {
        /varset c2 ${Request.Token[2," "].Lower}
        /varset c3 ${Request.Token[3," "].Lower}
        /varset c4 ${Request.Token[4," "]}
        /varset c5 ${Request.Token[5," "]}

        /if (${c2.Equal[on]}) {
            /call to_channel "-- Watch HP *ON*"
            /varset WatchHP 1
            /return
        }
        /if (${c2.Equal[off]}) {
            /call to_channel "-- Watch HP *OFF*"
            /varset WatchHP 0
            /return
        }
        /if (${c2.Equal[list]}) {
            /call ShowWatchHP
            /return
        }
        /if (${c2.Equal[reset]}) {
            /call ResetWatchHP
            /return
        }
        /if (${c2.Equal[resetorig]}) {
            /varset OrigWatchHP
            /return
        }
        /if (${c2.Equal[add]}) {
			|/echo ADD c3 = ${c3}  c4 = ${c4}  c5 = ${c5}
            /if (${c5.Equal[NULL]}) {
                /varset c5 ${c4}
                /varset c4 ${c3}
                /varset c3 ${Requestor}
            }
            /if (${c5.Equal[NULL]}) {
                /call to_channel "-- Invalid WatchHP syntax - ${c2} ${c3} ${c4} ${c5}"
                /return
            }
            /if (${Defined[SpellInfo_${c4}]}) {
                |/varset SpellDuration ${c5}
                /call GetDuration "${c4}"
				|| - Adding group, groupc, groupm, grouph, groupt
				/varset c6 NULL
				/if ( ${c3.Equal[group]} ) /varset c6 ${AllClassList}
				/if ( ${c3.Equal[groupc]} ) /varset c6 ${CasterList}
				/if ( ${c3.Equal[groupm]} ) /varset c6 ${MeleeList}
				/if ( ${c3.Equal[grouph]} ) /varset c6 ${HybridList}
				/if ( ${c3.Equal[groupt]} ) /varset c6 ${TankList}
				/if ( ${c6.NotEqual[NULL]} ) {
		            /for G 0 to ${Group}
		                /if (${c6.Find[${Group.Member[${G}].Class.ShortName}]}) /call AddToWatchHP "${Group.Member[${G}].CleanName}" "${c4}" "${c5}" ${SpellDuration}
		            /next G
					/return
				}
				/if ( ${c3.Equal[raid]} ) /varset c6 ${AllClassList}
				/if ( ${c3.Equal[raidc]} ) /varset c6 ${CasterList}
				/if ( ${c3.Equal[raidm]} ) /varset c6 ${MeleeList}
				/if ( ${c3.Equal[raidh]} ) /varset c6 ${HybridList}
				/if ( ${c3.Equal[raidt]} ) /varset c6 ${TankList}
				/if ( ${c6.NotEqual[NULL]} ) {
					/for G 1 to ${Raid.Members} 
		                /if (${c6.Find[${Raid.Member[${G}].Class.ShortName}]}) /call AddToWatchHP "${Raid.Member[${G}].Name}" "${c4}" "${c5}" ${SpellDuration}
		            /next G
					/return
				}

				/if ( ${c3.Equal[all]} ) {
					/for G 1 to ${NetBots.Counts}
						/varset c6 ${NetBots.Client.Arg[${G}," "]}
						/call AddToWatchHP "${c6}" "${c4}" "${c5}" ${SpellDuration}
					/next G
					/return
				}


				/call AddToWatchHP "${c3}" "${c4}" "${c5}" ${SpellDuration}
            } else {
                /call to_channel "-- Unknown WatchHP Spell ${c3}"
            }
        }
        /if (${c2.Equal[delete]}) {
            /call DeleteWatchHP ${c3}
            /return
        }
        /if (${c2.Equal[del]}) {
            /call DeleteWatchHP ${c3}
            /return
        }

    }
	
	| Request: voa | rof | cof | tds | gs | 
	/if ( ${c1.Equal[voa]} || ${c1.Equal[rof]} || ${c1.Equal[cof]} || ${c1.Equal[gs]} || ${c1.Equal[tds]} ) {
		/if ( ${c1.Equal[voa]} ) /varset c2 Chunk of Argathian Steel
		/if ( ${c1.Equal[rof]} ) /varset c2 Stone of the Shard's Fall
		/if ( ${c1.Equal[cof]} ) /varset c2 Stormstone of the West
		/if ( ${c1.Equal[tds]} ) /varset c2 Drowned Katta Castrum Powerstone
		/if ( ${c1.Equal[gs]}  ) /varset c2 Splinter from a Guild Standard
		
		/if ( ${Zone.ID} == 345 ) {
			/varset c3 Zeflmin
			/if (${Math.Distance[${Me.Y},${Me.X}:0,0]} < 50) {			
				/play gh1_gnome smart normal forward
			}
		} else /if ( ${Zone.ID} == 33505 ) {
			/varset c3 Teleportation Assistant
			/play gh2_gnome smart normal forward
		} else {
			/echo Can't get guild portal
			/return
		}
		
		/target npc ${c3}
		/echo waiting for path to finish ....
		/delay 30s !${AdvPath.Playing}
		/echo path done . Do we have a ${c2} ? 
		/if (!${FindItem[${c2}].ID}) {				
				/echo need to buy [${c2}] from [${c3}]
				/target npc ${c3}
				/nomodkey /click right target
				/delay 5s !${Window[MerchantWnd].Open}
				/delay 5
				/call Buy "${c2}" 1
				/echo Should have 1x [${c2}] now.
				/keypress ESC
				/keypress ESC
			}
		/target npc ${c3}
		/delay 5s ${Target.ID}

		/squelch /nomodkey /ctrlkey /itemnotify ${FindItem[${c2}].InvSlot} leftmouseup
        /click left target
		
        /echo Giving ${Cursor.Name} to ${Target.CleanName}
        /delay 5
        /notify TradeWnd TRDW_Trade_Button LeftMouseUp
        /delay 5
        /if (${Window[InventoryWindow].Open}) /keypress i
		/echo Portal should be now set
	}	
	
	| Request: cr
	/if ( ${c1.Equal[cr]} ) {
		/echo ${Zone}
		/if (${Zone.ID} == 344 ) {
		
			/play cr smart normal
			/delay 30s !${AdvPath.Playing}
			|/echo Should be in front of Disciple
			/if (!${FindItem[Coalescent Soulstone].ID}) {				
				|/echo need to buy soulstone
				/target Disciple
				/delay 2
				/nomodkey /click right target
				/delay 5s ${Window[MerchantWnd].Open}
				/delay 5s
				/call Buy "Torrential Soulstone" 1
				/delay 2s
				|/echo Buy should be done.
			}

			| move to priestess of Luclin
			|/echo Start moving to priestess
			/play cr_1_2 smart
			/delay 30s !${AdvPath.Playing}
			|/echo Should be at the priestess now.
			| handin the soulstone to priestess
			/target priestess
			/call ProcessRequest ${Me.Name} "handin Soulstone"
			/autoinventory
		}
	}

	| Request gh 
	/if ( ${c1.Equal[gh]} ) {
		/echo ${Zone}
		/if (${Zone.ID} == 344 ) {
			
			/if (${Math.Distance[${Me.X},${Me.Y}:0,0]} < 100) {			
				/play gh2 smart forward
			}

			/if (${Math.Distance[${Me.X},${Me.Y}:0,200]} < 100) {			
				/play gh2 smart forward
			}

			/if (${Math.Distance[${Me.X},${Me.Y}:-250,410]} < 100) {
				/play gh1 smart forward
			}

			/if (${Math.Distance[${Me.X},${Me.Y}:0,350]} < 100) {			
				/play gh2 smart forward
			}
		}
	}

	| Request: gearscore
	/if ( ${c1.Equal[gearscore]} ) {
		/if (${GearScore.Best.NotEqual[NULL]}) {
			/bc GearScore: ${GearScore.Best}
		}
	}

	| Request: RndSayText
	/if (${c1.Equal[rsay]}) {
		/varset RndSayText ${Request.Right[${Math.Calc[${Request.Length}-5]}]}
        /call AssistPlayer "${Requestor}"
		/varset RndSayTarg ${Target.ID}
		/varcalc RndSayTimer ${Math.Rand[120]}
		|/echo -- in [${RndSayTimer}] Say [${RndSayText}] to [${RndSayTarg}] = ${Spawn[id ${RndSayTarg}]}
        /return
	}


	| Request: Merc
	/if ( ${c1.Equal[merc]} ) {
		/varset c2 ${Request.Token[2," "].Lower}
		/if ( ${c2.Equal[assist]} ) /nomodkey /notify MMGW_ManageWnd MMGW_CallForAssistButton LeftMouseUp
		/if ( ${c2.Equal[auto]} ) /nomodkey /notify MMGW_ManageWnd MMGW_AssistModeCheckbox LeftMouseUp
		/if ( ${c2.Equal[show]} && ${Me.Mercenary.State.Equal[SUSPENDED]}) /nomodkey /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
		/if ( ${c2.Equal[show]} &&  ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Text.Equal[Revive]}) /nomodkey /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
		/if ( ${c2.Equal[hide]} && !${Me.Mercenary.State.Equal[SUSPENDED]}) /nomodkey /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
		/if ( ${c2.Equal[hide]} &&  ${Window[MMGW_ManageWnd].Open}) /nomodkey /notify MMGW_ManageWnd 0 close
	}
		
	| Request: Run
    /if ( ${c1.Equal[run]} ) {
        /varset c2 ${Request.Token[2," "].Lower}
        /varset c3 ${Request.Token[3," "].Lower}
        /varset c4 ${Request.Token[4," "]}
        /varset c5 ${Request.Token[5," "].Lower}
        /if ( ${c2.Equal[to]} ) {
            |run to 100 200 e
            /if ( (${Int[${c3}]} || ${c3.Equal[0]}) && (${Int[${c4}]} || ${c4.Equal[0]}) ) {
                /call MoveToLoc "${c3}" "${c4}"
                /if (${c5.Length} > 0) /call FaceDir "${c5}"
            }
        }
        /if ( ${c2.Equal[forward]} ) {
            /if (${Int[${c3}]} > 0) {
                /declare tmpRun int ${Math.Calc[${Int[${c3}]} / 100]}
                /call to_channel "-- Running forward for ${c3}ms"
                /keypress forward hold
                /delay ${tmpRun}
                /keypress forward
                /call to_channel "-- Done"
            }
        }

        /if ( ${c2.Equal[backward]} || ${c2.Equal[backwards]} || ${c2.Equal[back]} ) {
            /if (${Int[${c3}]} > 0) {
                /declare tmpRun int ${Math.Calc[${Int[${c3}]} / 100]}
                /call to_channel "-- Running backward for ${c3}ms"
                /keypress back hold
                /delay ${tmpRun}
                /keypress back
                /call to_channel "-- Done"
            }
        }
    }
    /if ( ${c1.Equal[face]} ) {
        /varset c2 ${Request.Token[2," "].Lower}
        /call FaceDir ${c2}
    }
    /if ( ${c1.Equal[channel]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}

        /if (${c2.Equal[group]}) {
            /varset mcsChannel /g
            /call to_channel "-- Default chat channel should now be group"
			/return
        }
        /if (${c2.Equal[guild]}) {
            /varset mcsChannel /guildsay
            /call to_channel "-- Default chat channel should now be guild"
			/return
        }
        /if (${c2.Equal[say]}) {
            /varset mcsChannel /say
            /call to_channel "-- Default chat channel should now be say"
			/return
        }
        /if (${c2.Equal[tell]}) {
            /if (${c3.Length} > 0) {
                /varset mcsChannel /t ${c3}
                /call to_channel "-- Default chat channel should now be tells to ${c3}"
            } else {
                /call to_channel "-- If you specify tell as a channel you must have playername also. Channel is not changed."
            }
			/return
        }
        /if (${c2.Left[1].Equal[/]}) {
            /varset mcsChannel ${c2}
            /call to_channel "-- Default chat channel should now be ${c2}"
			/return
        }
		/varset mcsChannelName ${c2}
		/list

    }

	| Request: dz
    /if ( ${c1.Equal[dz]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}

        /if (${c2.Equal[makeleader]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /dzmakeleader ${c3}
        }
        /if (${c2.Equal[invite]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /dzaddplayer ${c3}
        }
        /if (${c2.Equal[join]}) {
            /notify ConfirmationDialogBox Yes_Button leftmouseup
            /delay 1s
            /keypress ESC
        }
        /if (${c2.Equal[remove]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /dzremoveplayer ${c3}
        }
        /if (${c2.Equal[leave]}) {
            /dzquit
        }
        /return
    }

	| Request: Task
    /if ( ${c1.Equal[task]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}

        /if (${c2.Equal[makeleader]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /taskmakeleader ${c3}
        }
        /if (${c2.Equal[invite]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /taskaddplayer ${c3}
        }
        /if (${c2.Equal[join]}) {
            /notify ConfirmationDialogBox Yes_Button leftmouseup
            /delay 1s
            /keypress ESC
        }
        /if (${c2.Equal[remove]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /taskremoveplayer ${c3}
        }
        /if (${c2.Equal[leave]}) {
            /taskquit
        }
		/if (${c2.Equal[hud]}) {
			/varcalc TaskHud 1
			/varset DPSTimer 0
		}
		/if (${c2.Equal[nohud]}) {
			/varcalc TaskHud 0
			/varset DPSTimer 0
		}
        /return
    }

	/if ( ${c1.Equal[fps]} ) {
		/varset DoTimeCnt 20
		/varset DoTimeRef ${Time.SecondsSinceMidnight}
		/varset DoTimeRep 1 
		/return
	}

	/if ( ${c1.Equal[autoattack]} ) {
		/varset c2 ${Request.Arg[2," "].Lower}
		/if (${c2.Equal[on]} || ${Int[${c2}]}>0) {
			/varset PassiveCombat ${Int[${c2}]}
			/if (${PassiveCombat}==0) /varset PassiveCombat 100
			/if (${GroupMA.Equal[NULL]}) /varset GroupMA ${Requestor}
		}
		/if (${c2.Equal[off]}) {
			/varset PassiveCombat 0
			/varset GroupMA NULL
		}
		/if (${PassiveCombat}) {
			/call to_channel "setting AutoAttack is ON : assisting ${GroupMA}"
		} else {
			/call to_channel "setting AutoAttack is OFF"
		}
	}


    /if ( ${c1.Equal[combatover]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
		/varset c3 ${Request.Arg[3," "].Lower}
        /if (${c2.Equal[list]}) /call ShowCombatOver 
		/if (${c2.Equal[del]}) /call DeleteCombatOver "${c3}"
        /if (${c2.Equal[add]}) /call AddCombatOver "${Request.Right[ ${Math.Calc[ ${Request.Length} - 15 ]} ]}"
		/return
	}


    /if ( ${c1.Equal[combat]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /varset c4 ${Request.Arg[4," "]}
        /varset c5 ${Request.Arg[5," "]}
        /varset c6 ${Request.Arg[6," "]}
        /varset c7 ${Request.Arg[7," "]}

        /if (${c2.Equal[off]}) {
			/varset MobID 0
            /varset InCombat 0
            /for a 1 to ${MaxCombat}
                /varset CombatAction[${a}] 1
            /next a
            /varset DotRecastList
            /varset CombatAssist NULL
            /if (${DownTimeTwist.NotEqual[NULL]}) /squelch /mcs twist ${DownTimeTwist}
            /attack off
			/if (${Me.AutoFire}) /autofire
            /keypress ESC
        }

        /if (${c2.Equal[on]}) {
			/if (${UseOOCNow}) {
				/call to_channel "Out of Combat -- Mana at ${Me.PctMana}"
				/return
			}
            /if (${DoingMez}) /return
            /varset InCombat 1
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
            /varset CombatAssist ${c3}
            |/echo Combat *ON*
            /varset CombatCheck 0
	        /if (!${MobID}) {
		        /varset MobID ${Me.GroupAssistTarget.ID}
			    /if (${MobID}) /goto :HaveID
				/varset MobID ${Me.GroupMarkNPC[1].ID}
				/if (${MobID}) /goto :HaveID
			}

			:HaveID
        }


        /if (${c2.Equal[list]}) {
            /call ShowCombat
        }

        /if (${c2.Equal[add]}) {
            /if (${c3.Equal[cast]}) /call AddCombat "${c3}" "${c4}" "0" "${c5}" "${c6}"
            /if (${c3.Equal[cmd]}) {
                /declare aCombat int
                /if (${c7.NotEqual[NULL]}) {
                    /for aCombat 7 to ${Math.Calc[${Request.Count[" "]} + 1]}
                        /varset c6 ${c6} ${Request.Arg[${aCombat}," "]}
                    /next aCombat
                }
                /call AddCombat "${c3}" "${c4}" "0" "${c5}" "${c6}"
            }
            /if (${c3.Equal[recast]}) /call AddCombat "${c3}" "${c4}" "${c5}" "${c6}" "${c7}"
        }

        /if (${c2.Equal[delete]} || ${c2.Equal[del]}) {
            /call DeleteCombat "${c3}"
        }

        /if (${c2.Equal[recast]}) {
            /if (${c3.Equal[on]}) {
                /call to_channel "-- Buff Recast During Combat *ON*"
                /varset CombatRecast 1
            }
            /if (${c3.Equal[off]}) {
                /call to_channel "-- Buff Recast During Combat *OFF*"
                /varset CombatRecast 0
            }
        }

    }

    /if ( ${c1.Equal[castermelee]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}

        /if (${c2.Equal[on]}) {
			/if (${UseOOCNow}) {
				/call to_channel "Out of Combat -- Mana at ${Me.PctMana}"
				/return
			}
            /varset CasterMelee 1
            /if ( !${Me.Standing} ) /stand
            /call to_channel "-- Caster Melee *ON*"
        }

        /if (${c2.Equal[off]}) {
            /varset CasterMelee 0
            /call to_channel "-- Caster Melee *OFF*"
        }
        /if (${c2.Equal[now]}) {
            /if (${c3.Equal[NULL]}) /varset c3 ${Requestor}
			/varset CasterMelee 1
            /call AssistPlayer "${c3}"
            /delay 5
            /if ( !${Me.Standing} ) /stand
            /squelch /stick ${MeleeStick}
            /varset Sticking 1
            /attack on
            /varset MobID ${Target.ID}
        }
        /return
    }

    /if ( ${c1.Equal[setma]} ) {
        /varset c2 ${Request.Arg[2," "]}
        /varset GroupMA ${c2}
        /call to_channel "-- Main assist set as ${GroupMA}"
    }

    /if ( ${c1.Equal[melee]} ) {
        /if (!${MobID}) {
            /varset MobID ${Me.GroupAssistTarget.ID}
            /if (${MobID}) /goto :HaveID
            /varset MobID ${Me.GroupMarkNPC[1].ID}
            /if (${MobID}) /goto :HaveID
        }
		/if (${DoingMez}) /return
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[NULL]}) /varset c3 ${GroupMA}
        /call AssistPlayer "${c3}"
        /varset MobID ${Target.ID}

        :HaveID
        /if ( !${Me.Standing} ) /stand
        /target id ${MobID}
        /delay 5
        /squelch /stick ${MeleeStick}
		/varset MeleeOn 1
	    /varset Sticking 1
        /attack on
		/killthis
        /varset MobID ${Target.ID}

		|/echo MobID = ${MobID}
        /return
    }

    /if ( ${c1.Equal[ranged]} ) {
        /if (!${MobID}) {
            /varset MobID ${Me.GroupAssistTarget.ID}
            /if (${MobID}) /goto :HaveID
            /varset MobID ${Me.GroupMarkNPC[1].ID}
            /if (${MobID}) /goto :HaveID
        }

        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[NULL]}) /varset c3 ${GroupMA}
        /call AssistPlayer "${c3}"
        /varset MobID ${Target.ID}

        :HaveID
        /if ( !${Me.Standing} ) /stand
        /target id ${MobID}
        /delay 5
        /face fast nolook
        /squelch /stick 40 hold moveback loose
        |/varset Sticking 1
		/timed 20 /stick off
        /if (!${Me.AutoFire}) /autofire
        /varset MobID ${Target.ID}
        /return
    }

    /if ( ${c1.Equal[add]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.NotEqual[NULL]} && ${Int[${c2}]}) {
            /if (${Me.Class.ShortName.Equal[BRD]}) /call BardMez ${c2}
            /if (${Me.Class.ShortName.Equal[ENC]}) /call EnchanterMez ${c2}
        }
    }

    /if ( ${c1.Equal[domez]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /if (${c2.Equal[on]}) {
            /varset DoMez 1
			/xtarget set 1 groupassisttarget
            /call to_channel "-- Auto Mezzing *ON*"
        }

        /if (${c2.Equal[off]}) {
            /varset DoMez 0
            /call to_channel "-- Auto Mezzing *OFF*"
        }

        /if (${c2.Equal[radius]}) {
            /varset MezRadius ${c3}
            /call to_channel "-- Mez radius now ${MezRadius} units"
        }

        /if (${c2.Equal[spell]}) {
            /varset MezSpell ${Request.Right[${Math.Calc[${Request.Length}-12]}]}
            /call to_channel "-- Mez Spell set to -${MezSpell}-"
        }
    }

    /if ( ${c1.Equal[offtank]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /if (${c2.Equal[on]}) {
            /varset OffTank 1
            /call to_channel "-- Off Tanking *ON*"
        }

        /if (${c2.Equal[off]}) {
            /varset OffTank 0
            /call to_channel "-- Off Tanking *OFF*"
        }

        /if (${c2.Equal[radius]}) {
            /varset MezRadius ${c3}
            /call to_channel "-- Off Tank radius now ${MezRadius} units"
        }
    }


    /if ( ${c1.Equal[attack]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[on]}) /attack on
        /if (${c2.Equal[off]}) /attack off
        /return
    }

    /if ( ${c1.Equal[recast]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /if (${c2.Equal[on]}) {
            /varset NeedToRecast 1
            /varset WantToRecast 1
            /call to_channel "-- Spell Recast *ON*"
        }
        /if (${c2.Equal[off]}) {
            /varset NeedToRecast 0
            /varset WantToRecast 0
            /call to_channel "-- Spell Recast *OFF*"
        }
        /if (${c2.Equal[del]}) {
            /call DeleteRecast ${c3}
        }
        /if (${c2.Equal[list]}) {
            /call ShowRecasts
        }
        /return
    }

    /if ( ${c1.Equal[petkit]} ) {
        /if (${Me.Class.ShortName.NotEqual[MAG]}) {
            /call to_channel "-- Only valid for Magicians, sorry."
            /return
        }
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /varset c4 ${Request.Arg[4," "].Lower}

        /if (${c2.Equal[weapon]}) {
            /varset PetWeaponSpell ${c3}
            /return
        }
        /if (${c2.Equal[belt]}) {
            /varset PetBeltSpell ${c3}
            /return
        }
        /if (${c2.Equal[mask]}) {
            /varset PetMaskSpell ${c3}
            /return
        }
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
        /call TargetPlayer ${c2}
        /delay 1s

        /call to_channel "-- Giving pet kit to ${Target.CleanName}"

        /if (${PetWeaponSpell.Length} > 0 ) /call CastSpell "${PetWeaponSpell}" "blind"
        /delay 3s
        /if (${PetWeaponSpell.Length} > 0 ) /call CastSpell "${PetWeaponSpell}" "blind"
        /delay 3s
        /call TargetPlayer ${c2}
        /if (${Target.Distance} > 15) /call MoveToSpawn ${Target.ID} 16
        /delay 1s
        /click left target
        /delay 2s
        /click left target
        /delay 2s
        /if (${Window[TradeWnd].Open}) {
            /notify TradeWnd TRDW_Trade_Button LeftMouseUp
            /delay 5s !${Window[TradeWnd].Open}
        } else {
            /if (${Window[GiveWnd].Open}) /notify GiveWnd GVW_Give_Button LeftMouseUp
        }


        /delay 1s
        /if (${PetBeltSpell.Length} > 0 ) /call CastSpell "${PetBeltSpell}" "blind"
        /delay 1s
        /call TargetPlayer ${c2}
        /delay 2s
        /click left target
        /delay 2s
        /if (${Window[TradeWnd].Open}) {
            /notify TradeWnd TRDW_Trade_Button LeftMouseUp
            /delay 5s !${Window[TradeWnd].Open}
        } else {
            /if (${Window[GiveWnd].Open}) /notify GiveWnd GVW_Give_Button LeftMouseUp
        }

        /delay 1s
        /if (${PetMaskSpell.Length} > 0 ) /call CastSpell "${PetMaskSpell}" "blind"
        /delay 2s
        /call TargetPlayer ${c2}
        /delay 2s
        /click left target
        /delay 2s
        /if (${Window[TradeWnd].Open}) {
            /notify TradeWnd TRDW_Trade_Button LeftMouseUp
            /delay 5s !${Window[TradeWnd].Open}
        } else {
            /if (${Window[GiveWnd].Open}) /notify GiveWnd GVW_Give_Button LeftMouseUp
        }
        /keypress ESC
        /keypress ESC

    }

	| Request:  downtwist
    /if ( ${c1.Equal[downtwist]} ) {
        /varset DownTimeTwist ${Request.Right[${Math.Calc[${Request.Length}-10]}]}
        /call to_channel "-- Downtime Twist set to ${DownTimeTwist}"
    }

	| Request:  waitrez
    /if ( ${c1.Equal[waitrez]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[on]}) {
            /call to_channel "-- Waiting for a rez..."
            /varset CheckForRez 1
        }
        /if (${c2.Equal[off]}) {
            /call to_channel "-- No longer waiting for a rez..."
            /varset CheckForRez 0
        }
    }

	| Request:  DoCanni
    /if ( ${c1.Equal[docanni]} ) {
        /varset c2 ${Request.Token[2," "].Lower}
        /varset c3 ${Request.Token[3," "].Lower}
        /varset c4 ${Request.Token[4," "].Lower}
        /if (${c2.Equal[auto]}) {
            /call to_channel "-- AutoCanni *ON*"
            /varset Canni 1
        }
        /if (${c2.Equal[noauto]}) {
            /call to_channel "-- AutoCanni *OFF*"
            /varset Canni 0
        }
        /if (${c2.Equal[combat]}) {
            /if (${c3.Equal[on]}) {
                /call to_channel "-- Canni During Combat *ON*"
                /varset CombatCanni 1
            }
            /if (${c3.Equal[off]}) {
                /call to_channel "-- Canni During Combat *OFF*"
                /varset CombatCanni 0
            }
        }
        /if (${c2.Equal[hp]}) {
            /varset CanniHP ${c3}
            /call to_channel "-- Canni minimum hp now ${CanniHP}%"
        }
        /if (${c2.Equal[mana]}) {
            /varset CanniMana ${c3}
            /call to_channel "-- Canni minimum mana now ${CanniMana}%"
        }
        /if (${c2.Equal[delay]}) {
            /varset CanniDelay ${c3}
            /call to_channel "-- Canni recast delay now ${CanniDelay} seconds"
        }
        /if (${c2.Equal[v]}) {
            /if (${c3.Equal[hp]}) {
                /varset CanniVHP ${c4}
                /call to_channel "-- Canni V minimum hp now ${CanniVHP}%"
            }
            /if (${c3.Equal[mana]}) {
                /varset CanniVMana ${c4}
                /call to_channel "-- Canni V minimum mana now ${CanniVMana}%"
            }
        }
    }

	| Request:  HandIn
    /if ( ${c1.Equal[handin]} ) {
		/echo Handin
        /varset c2 ${Request.Token[2," "].Lower}
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
        /call AssistPlayer ${Requestor}
        /delay 5

		/echo ItemToCursor
		/if (${c2.NotEqual[NULL]}) /call ItemToCursor ${c2}

        /click left target
        /echo Giving ${Cursor.Name} to ${Target.CleanName}
        /delay 2s
        /notify TradeWnd TRDW_Trade_Button LeftMouseUp
        /delay 1s
        /if (${Window[InventoryWindow].Open}) /keypress i
    }


	| Request:  Recrystal
    /if ( ${c1.Equal[recrystal]} ) {
        /varset c2 ${Request.Token[2," "].Lower}
        /if (!${Window[InventoryWindow].Open}) /keypress i
        /delay 5
        /notify InventoryWindow IW_ReclaimButton leftmouseup
        /delay 5
        /if (${c2.Equal[evil]}) /shiftkey /notify InventoryWindow IW_EvilPoints leftmouseup
        /if (${c2.Equal[good]}) /shiftkey /notify InventoryWindow IW_GoodPoints leftmouseup
        /delay 5
        /keypress i
    }

	| Request: GiveMe
    /if ( ${c1.Equal[giveme]} ) {
        /declare TradeCount int 0
        /varset c2 ${Request.Token[2," "].Lower}
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
        /call TargetPlayer ${c2}
        /echo Giving ${Target.CleanName} ${Cursor.Name}
        :StartTrade
            /varcalc TradeCount ${TradeCount} + 1
            /if (${TradeCount} > 15) /return
            /delay 5
            /click left target
            /delay 2s
        /if (!${Window[TradeWnd].Open}) /goto :StartTrade
        /notify TradeWnd TRDW_Trade_Button LeftMouseUp
        /return
    }

	| Request: VIS
	/if ( ${c1.Equal[vis]} ) {
		/makemevis
		|/mcs clickoff camouflage
		|/mcs clickoff distract
		|/mcs clickoff silent
	}
	
	| Request: ClickOff
	/if ( ${c1.Equal[clickoff]} ) {
		/varset c2 ${Request.Right[${Math.Calc[${Request.Length}-9]}]}
		/echo -- clickoff all buffs with [${c2}] in the name.
		/for G 0 to 36
			|/echo -  $ {Me.Buff[${G}].Spell.Name} = ${Me.Buff[${G}].Spell.Name}
			
			/if (${Window[BuffWindow].Child[Buff${G}].Tooltip.Find[${c2}]}) {			
				/varcalc a ${G}
				/notify BuffWindow Buff${a} leftmouseup
				/echo -- Removing buff "${Window[BuffWindow].Child[Buff${G}].Tooltip}" /notify BuffWindow Buff${a} leftmouseup
				/delay 1
			}
		/next G
		/for G 1 to 19
			/if (${Window[ShortDurationBuffWindow].Child[Buff${G}].Tooltip.Find[${c2}]}) {
				/echo -- Removing song :  ${Window[ShortDurationBuffWindow].Child[Buff${G}].Tooltip}
				/varcalc a ${G}
				/notify ShortDurationBuffWindow Buff${a} leftmouseup
				/delay 1
			}	
		/next G
		/if (${Window[CombatAbilityWnd].Child[CAW_CombatEffectLabel].Text.Find[${c2}]}) {
			/echo -- Removing Disc
			/notify CombatAbilityWnd CAW_CombatEffectButton leftmouseup
		}
		/return
	}
	

	
	||-- ELH -- New Chain casting
	| Request: Chain 
	/if ( ${c1.Equal[chain]} ) {
		/varset c2 ${Request.Token[2," "].Lower}
		/varset c3 ${Request.Token[3," "].Lower}
		/varset c4 ${Request.Token[4," "].Lower}
		/varset c5 ${Request.Token[5," "].Lower}
		/varset c6 ${Request.Token[6," "].Lower}
		/varset c7 ${Request.Token[7," "].Lower}
		/varset c8 ${Request.Token[8," "].Lower}
		/varset c9 ${Request.Token[9," "].Lower}


		/if (${c2.Equal[NULL]}) { 
			/call to_channel "-- Chain cast spell > ${ChainSpell} < every ${ChainRecast} sec , starting after ${ChainInitialPause} sec. 
			/call to_channel "-- Chain cast on targets [ ${ChainTarget1}, ${ChainTarget2}, ${ChainTarget3} ]
			/return
		}

		/if (${c2.Equal[on]}) {
		    /if (${ChainTarget1.Equal[NULL]}) /return
			/if (${ChainSpell.Equal[NULL]}) /return
			/if (${ChainTarget1.Equal[ ]}) /return
			/call to_channel "-- Chain casting *ON*"
			/varset DoingChain 1
			/varcalc ChainNextTime ${Time.SecondsSinceMidnight} + ${ChainInitialPause}
			/if (${ChainTarget1.Equal[Assist]}) {
				/varset ChainListChID 0
				/varset MobID 0
				/return
			}
			/if (${ChainTarget1.NotEqual[Blind]}) /target ${ChainTarget1}

			/return
		}
		/if (${c2.Equal[off]}) {
			/call to_channel "-- Chain casting *OFF*"
			/varset DoingChain 0
			/return
		}
		/if (${c2.Equal[failed]}) {
			/if (${c3.NotEqual[NULL]}) /varset ChainFailed ${c3}
			/echo If chain fails do > ${ChainFailed} < 
			/return
		}
		/if (${c2.Equal[cast]}) {
			/varset ChainSpell ${c3}
			/varset ChainRecast ${c4}
			/varset ChainInitialPause ${c5}
			/call to_channel "-- Chain cast spell > ${ChainSpell} < every ${ChainRecast} sec , starting after ${ChainInitialPause} sec. "
			/if (${c6.Equal[on]}) {
				/if (${c7.Equal[NULL]}) /varset c7 "blind"
				/varset ChainTarget1 ${c7}
				/varset ChainTarget2 ${c8}
				/varset ChainTarget3 ${c9}
				/call to_channel "-- Chain cast on targets [ ${ChainTarget1}, ${ChainTarget2}, ${ChainTarget3} ]"
			}
			/varset ChainIsCH 0
			/return
		}
		/if (${c2.Equal[targets]}) {
			/if (${c3.Equal[NULL]}) /varset c3 "blind"
			/varset ChainTarget1 ${c3}
			/varset ChainTarget2 ${c4}
			/varset ChainTarget3 ${c5}
			/call to_channel "-- Chain cast on targets [ ${ChainTarget1}, ${ChainTarget2}, ${ChainTarget3} ]"
			/return
		}

		/if (${c2.Equal[stopsonexp]}) {
			/if (${c3.Equal[on]} || ${c3.Equal[NULL]}) {
				/varset ChainStopOnExp 1
				/call to_channel "-- Chain Stops On Exp "
			} else {
				/varset ChainStopOnExp 0
				/call to_channel "-- Chain does NOT Stop On Exp "
			}
			/return
		}
	}

	| Request: CHChain
	/if ( ${c1.Equal[chchain]} ) {
		/varset c2 ${Request.Token[2," "].Lower}
		/varset c3 ${Request.Token[3," "].Lower}
		/varset c4 ${Request.Token[4," "].Lower}
		/varset c5 ${Request.Token[5," "].Lower}
		/varset c6 ${Request.Token[6," "].Lower}
		/varset c7 ${Request.Token[7," "].Lower}
		/varset c8 ${Request.Token[8," "].Lower}
		/varset c9 ${Request.Token[9," "].Lower}

        /if (${c2.Equal[NULL]}) { 
			/return
		}

		/varset a 8
		/if (${c9.Equal[NULL]})	/varset a 7
		/if (${c8.Equal[NULL]})	/varset a 6
		/if (${c7.Equal[NULL]})	/varset a 5
		/if (${c6.Equal[NULL]})	/varset a 4
		/if (${c5.Equal[NULL]})	/varset a 3
		/if (${c4.Equal[NULL]})	/varset a 2
		/if (${c3.Equal[NULL]})	/varset a 1
		/if (${c2.Equal[NULL]})	/varset a 0


		/declare i
		/varset i -1
		/if (${c2.Equal[${MyName}]}) /varset i 0
		/if (${c3.Equal[${MyName}]}) /varset i 1
		/if (${c4.Equal[${MyName}]}) /varset i 2
		/if (${c5.Equal[${MyName}]}) /varset i 3
		/if (${c6.Equal[${MyName}]}) /varset i 4
		/if (${c7.Equal[${MyName}]}) /varset i 5
		/if (${c8.Equal[${MyName}]}) /varset i 6
		/if (${c9.Equal[${MyName}]}) /varset i 7

		/if ( ${i} < 0 ) /return

		/varset ChainIsCH 1

		/varset ChainSpell ch
		/varset ChainRecast 15
		/varcalc ChainInitialPause 15 * ${i} / ${a}
		/varset ChainTarget1 assist
		/varset ChainTarget2 ${Requestor}
		/varset ChainListChID 0

		/echo -- Setting chain to cast ${ChainSpell} every ${ChainRecast} , I start ${ChainInitialPause} after ${ChainTarget1} ${ChainTarget2}
	}

	| Request: LootAll
    /if ( ${c1.Equal[lootall]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
		/varset c3 ${Request.Arg[3," "]}
        /if (${c2.Equal[on]}) {
            /call to_channel "-- Corpse Looting *ON*"
            /varset LootAllCorpses 1
        }
        /if (${c2.Equal[off]}) {
            /call to_channel "-- Corpse Looting *OFF*"
            /varset LootAllCorpses 0
        }
		/if (${c2.Equal[now]}) {
			/varset Looting TRUE
			/call LootMobs
			/varset Looting FALSE
		}
		/if (${c2.Equal[sell]}) {
			/if ( ${Target.Type.Equal[NPC]} || ${Target.Type.Equal[Pet]} )	/call DoLootStuff sell
			|/call SellToNPC
		}
		/if (${c2.Equal[trade]}) {
			/if ( ${Target.Type.Equal[PC]} )	/call HandleOpenTradeWindow
		}
		/if (${c2.Equal[trib]}) /call GiveTributeToNPC

		/if (${c2.Equal[report]}) {
			/if (${c3.Equal[NULL]}) { 
				/if (${ReportLoot} ) /call to_channel "-- Reporting drops left on corpses.
				/if (!${ReportLoot} ) /call to_channel "-- NOT Reporting drops left on corpses.
			}
			/if (${c3.Equal[on]}) {
				/call to_channel "-- Reporting drops left on corpses."
				/varset ReportLoot TRUE
			}
			/if (${c3.Equal[off]}) {
				/call to_channel "-- NOT Reporting drops left on corpses."
				/varset ReportLoot FALSE
			}
		}
    }

	| Request: MakePet
    /if ( ${c1.Equal[makepet]} ) {
		/echo makepet
		/echo !${Me.Pet.ID}
		/echo ${PetSpellName}
        /if (!${Me.Pet.ID} && ${PetSpellName.NotEqual[NULL]}) {
			/echo casting ${PetSpellName}
            /call CastSpell "${PetSpellName}" blind
        }
    }

	| Request: KeepPet
    /if ( ${c1.Equal[keeppet]} && ${PetSpellName.NotEqual[NULL]}) {
        /varset c2 ${Request.Arg[2," "].Lower}

        /if ( ${c2.Equal[on]} ) {
            /varset KeepPet 1
            /call to_channel "-- Always keeping a pet *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset KeepPet 0
            /call to_channel "-- Always keeping a pet *OFF*"
        }
    }

	| Request: UseDARB
    /if ( ${c1.Equal[usedarb]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}

        /if ( ${c2.Equal[on]} ) {
            /varset UseDarb 1
            /call to_channel "-- Divine Arbitration *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset UseDarb 0
            /call to_channel "-- Divine Arbitration *OFF*"
        }
        /if ( ${c2.Equal[hp]} ) {
            /varset DarbThreshold ${c3}
            /call to_channel "-- Divine Arbitration Threshold ${DarbThreshold}%"
        }
    }

	| Request: DOHB
    /if ( ${c1.Equal[dohb]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /if ( ${c2.Length} > 0 && ${c3.Length} > 0) {
            /squelch /twist off
            /keypress hotpage${c2}
            /delay 5
            /keypress ${c3}
        }
    }

	| Request: SpreadOut
    /if ( ${c1.Equal[spreadout]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (${c2.Equal[on]}) {
            /varset SpreadOutAfterFollow 1
            /call to_channel "-- Spread after follow *ON*"
        }

        /if (${c2.Equal[off]}) {
            /varset SpreadOutAfterFollow 0
            /call to_channel "-- Spread after follow *OFF*"
        }

        /if (${c2.Equal[now]}) {
            /call to_channel "-- Spreading out now"
            /call SpreadOut
        }


    }

	| Request: Twist
    /if ( ${c1.Equal[twist]} ) {
        /varset c2 ${Request.Right[${Math.Calc[${Request.Length}-6]}]}
        /varset c3 ${Twist.List}
        /if (!${Me.Standing}) /stand
        |/echo --${c3}--  --${c2}--
        /if (${Twist.List.Right[1].Equal[ ]}) /varset c3 ${c3.Left[${Math.Calc[${Twist.List.Length}-1]}]}
        |/echo --${c3}--  --${c2}--
        /if ((${Twist} && ${Twist.List.NotEqual[${c2} ]}) || !${Twist}) /squelch /twist ${c2}
        /return
    }

	| Request: Chat
    /if ( ${c1.Equal[chat]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset UseChatForNotify 1
            /call to_channel "-- UseChatForNotify *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset UseChatForNotify 0
            /call to_channel "-- UseChatForNotify *OFF*"
        }
        /return
    }
	
	| Request: IRC
    /if ( ${c1.Equal[irc]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset UseIRCForNotify 1
            /call to_channel "-- UseIRCForNotify *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset UseIRCForNotify 0
            /call to_channel "-- UseIRCForNotify *OFF*"
        }
        /if ( ${c2.Equal[reset]} ) {
            /squelch /i quit
            /call JoinIRC
            /call to_channel "-- Using IRC Channel ${IRCChannel} for communication"
        }
        /return
    }

	| Request: Debug
    /if ( ${c1.Equal[debug]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset UseDebugForNotify 1
            /call to_channel "-- UseDebugForNotify *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset UseDebugForNotify 0
            /call to_channel "-- UseDebugForNotify *OFF*"
        }
        /return
    }

	| Request: DoHarvest
    /if ( ${c1.Equal[doharvest]} ) {
        /if (${Me.Class.ShortName.NotEqual[WIZ]}) {
            /call to_channel "-- Only valid for Wizards, sorry."
            /return
        }
        /varset c2 ${Request.Token[2," "].Lower}
        /varset c3 ${Request.Token[3," "].Lower}
        /if (${c2.Equal[on]}) /varset DoHarvest 1
        /if (${c2.Equal[off]}) /varset DoHarvest 0
        /if (${c2.Equal[mana]}) {
            /varset HarvestMana ${c3}
            /call to_channel "-- Will Harvest if mana under ${HarvestMana}%"
        }
    }

	| Request: OnZone
    /if ( ${c1.Equal[onzone]} ) {
        /declare aCombat int
        /if (${c2.NotEqual[NULL]}) {
            /varset doOnZone
            /for aCombat 2 to ${Math.Calc[${Request.Count[" "]} + 1]}
                /varset doOnZone ${doOnZone} ${Request.Arg[${aCombat}," "]}
            /next aCombat
            /call to_channel "-- After next zone will execute ${doOnZone}"
        }
    }

	| Request: AutoMem
    /if ( ${c1.Equal[automem]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset c3 ${Request.Arg[3," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset AutoMem 1
            /call to_channel "-- Auto Mem Spells on death *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset AutoMem 0
            /call to_channel "-- Auto Mem Spells on death *OFF*"
        }
        /if ( ${c2.Equal[set]} ) {
            /varset AutoMemSetName ${c3}
            /call to_channel "-- Auto Mem Setname set to ${c3}"
        }
        /return
    }

	| Request: AutoAccept
    /if ( ${c1.Equal[autoaccept]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset AutoAccept 1
            /call to_channel "-- Clicking yes to everything."
        }
        /if ( ${c2.Equal[off]} ) {
            /varset AutoAccept 0
            /call to_channel "-- Not clicking yes to everything."
        }
        /return
    }
		
	| Request: AutoRez
    /if ( ${c1.Equal[autorez]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if ( ${c2.Equal[on]} ) {
            /varset AutoWaitRez 1
            /call to_channel "-- Auto wait for rez *ON*"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset AutoWaitRez 0
            /call to_channel "-- Auto wait for rez *OFF*"
        }
        /return
    }

	| Request: SetLoot
    /if ( ${c1.Equal[setloot]} ) {
		/if (!${Cursor.ID}) /call to_channel "-- setloot [Ignore|Destroy|Keep|Sell|Trib|Bank] while holding an item."
		/if (${Cursor.ID}) {
			/varset c2 ${Request.Arg[2," "].Lower}
			/varset c3 ${Ini[Loot.ini,${Cursor.Name.Left[1]},${Cursor.Name}]}
			/varset c4 "|Ignore|Destroy|Keep|Sell|Trib|Bank"
			/if ( ${c2.Equal[NULL]} ) {
				/echo -- setloot item: [${Cursor.Name}] currently ${c3}
			} else /if ( ${c4.Find[|${c2}|]} ) {
				/ini "loot.ini"  "${Cursor.Name.Left[1]}" "${Cursor.Name}" " ${c2}"
				/call to_channel "-- setloot item: [${Cursor.Name}] set to ${c2}
				/if (${c2.Equal[destroy]}) /destroy
			} else {
				/call to_channel "-- setloot ${c2} unknown . Use [Ignore|Destroy|Keep|Sell|Trib|Bank] while holding an item."
			}
		} 
	}
	
    /if ( ${c1.Equal[lootown]} ) {
        /if (${Spawn[${Me}'s Corpse].ID}) {
            /call to_channel "-- Looting my own corpse"
            /tar mycorpse
            /delay 5
            /squelch /cor
            /delay 5
            /squelch /cor
            /delay 1s
            /call LootTarget
        }
    }

    /if ( ${c1.Equal[loottar]} ) {
        /varset c2 ${Request.Arg[2," "]}
        /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
        /call AssistPlayer "${c2}"
        /call to_channel "-- Looting ${Target.CleanName}"
        /call LootTarget
    }

    /if ( ${c1.Equal[lootitem]} ) {
        /varset c2 ${Request.Right[${Math.Calc[${Request.Length}-9]}]}
        /if (${c2.Length} > 0) {
            /tar mycorpse
            /delay 5
            /squelch /cor
            /delay 5
            /squelch /cor
            /delay 5
            /squelch /cor
            /delay 1s
            /call LootItem ${c2}
        }
    }

    /if ( ${c1.Equal[pickup]} ) {
        /varset c2 ${Request.Right[${Math.Calc[${Request.Length}-7]}]}
        /if (${c2.Length} > 0) /call PickupItemSingle ${c2}
    }

    /if ( ${c1.Equal[pickupstack]} ) {
        /varset c2 ${Request.Right[${Math.Calc[${Request.Length}-12]}]}
        /if (${c2.Length} > 0) /call PickupItemStack ${c2}
    }

    /if ( ${c1.Equal[pickmonster]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /if (!${Window[TaskTemplateSelectWnd].Open}) {
            /call to_channel "-- Monster window not open, aborting..."
            /return
        }
        /if (${c2.Length} == 0) {
            /call to_channel "-- Invalid monster number, aborting..."
            /return
        }
        /call to_channel "-- Selecting monster number ${c2} from the list"
        | select monster from list
		/nomodkey /notify TaskTemplateSelectWnd TaskTemplateSelectListOptional listselect ${c2}
		/delay 2s
		/nomodkey /notify TaskTemplateSelectWnd TaskTemplateSelectAcceptButton leftmouseup
		/delay 1s
		/squelch /keypress ESC
    }

    /if ( ${c1.Equal[loadmmaa]} ) {
        /if (!${Window[AAWindow].Open}) /keypress v
        /delay 10s ${Window[AAWindow].Open}
        /notify AAWindow AAW_LoadButton Leftmouseup
        /delay 2s
        /cleanup
    }

	
	/if ( ${c1.Equal[buyaa]} ) {
	    /varset c2 ${Request.Arg[2," "]}
		/if (${c2.Equal[NULL]} || ${c2.Equal[on]} || ${c2.Equal[off]}) {
			/if (${c2.Equal[on]}) /varset AutoAA 1
			/if (${c2.Equal[off]}) /varset AutoAA 0
			/if (${AutoAA})  /call to_channel "-- AutoAA : on"
			/if (!${AutoAA}) /call to_channel "-- AutoAA : off"
			/return
		}
		/if (${c2.Equal[now]}) {
			/call AAPicker now
			/call AABalance
			/return
		}
	    /varset c2 ${Request.Right[${Math.Calc[${Request.Length}-6]}]}
        /if (${c2.Length} > 0) /call BuyAA "${c2}"
	}


    /if ( ${c1.Equal[autofollow]} ) {
        /varset c2 ${Request.Arg[2," "].Lower}
        /varset LDONWho ${Requestor}
        /if ( ${c2.Equal[on]} ) {
            /varset LDONMode 1
            /call to_channel "-- Autofollow Mode *ON* -- Will autofollow ${LDONWho}"
			/call ProcessRequest "${LDONWho}" "follow"
        }
        /if ( ${c2.Equal[off]} ) {
            /varset LDONMode 0
            /call to_channel "-- Autofollow Mode *OFF*"
        }

    }
|++++++++++++++++++++++++++++++++++++++++++++++++++++++++|

    /if (${UseNameToCast}) {
        /varset c1 ${c1.Lower}
        /if (${Defined[SpellInfo_${c1}]}) {
            /varset c2 ${Request.Arg[2," "].Lower}
            /varset c3 ${Request.Arg[3," "].Lower}
            /if (${c2.Equal[NULL]}) /varset c2 ${Requestor}
            /if (${c2.Equal[once]}) {
                /varset c2 ${Requestor}
                /varset c3 once
            }
            /if (${c2.Equal[group]}) {
                /for G 1 to ${Group}
                    /call CastSpell "${c1}" "${Group.Member[${G}].CleanName}" "${c3}"
                /next G
                /call CastSpell "${c1}" "self" "${c3}"
                /return
            }
            /if (${c2.Equal[grouppet]}) {
                /for G 1 to ${Group}
                    /if (${Group.Member[${G}].Pet.ID}) /call CastSpell "${c1}" "${Group.Member[${G}]}:pet" "${c3}"
                /next G
                /if (${Me.Pet.ID}) /call CastSpell "${c1}" "pet" "${c3}"
                /return
            }
            /if (${c2.Equal[groupc]}) {
                /for G 1 to ${Group}
                    /if (${CasterList.Find[${Group.Member[${G}].Class.ShortName}]}) /call CastSpell "${c1}" "${Group.Member[${G}].CleanName}" "${c3}"
                /next G
                /if (${CasterList.Find[${Me.Class.ShortName}]}) /call CastSpell "${c1}" "self" "${c3}"
                /return
            }
            /if (${c2.Equal[groupm]}) {
                /for G 1 to ${Group}
                    /if (${MeleeList.Find[${Group.Member[${G}].Class.ShortName}]}) /call CastSpell "${c1}" "${Group.Member[${G}].CleanName}" "${c3}"
                /next G
                /if (${MeleeList.Find[${Me.Class.ShortName}]}) /call CastSpell "${c1}" "self" "${c3}"
                /return
            }
            /if (${c2.Equal[grouph]}) {
                /for G 1 to ${Group}
                    /if (${HybridList.Find[${Group.Member[${G}].Class.ShortName}]}) /call CastSpell "${c1}" "${Group.Member[${G}].CleanName}" "${c3}"
                /next G
                /if (${HybridList.Find[${Me.Class.ShortName}]}) /call CastSpell "${c1}" "self" "${c3}"
                /return
            }

            /call CastSpell "${c1}" "${c2}" "${c3}"
        }
    }
}
/return


Sub BuyAA(string AANameStr)
|I had notthing to do with this Sub it is in the original form from 3-P-O
	/declare ListNum string local
	/declare i int local
	/declare G int local
	/declare Max int local
	/declare AAName string local 

	/varset AAName  ${AANameStr.Arg[1,"|"]}
	/varset Max     ${AANameStr.Arg[2,"|"]}

	/if (${Max}==0) /varset Max 1

	/varset ListNum List${AltAbility[${AAName}].Type}
	/if (${ListNum.Equal[ListNULL]}) {
		/echo Failed to buy AA for ${AAName}
		/return 
	}

	/for G 1 to ${Max}
		/if (!${AAName.Equal[NONE]} && ${AltAbility[${AAName}].Cost}<=${Me.AAPoints}) {
			/notify AAWindow AAW_Subwindows tabselect ${AltAbility[${AAName}].Type}
			/notify AAWindow ${ListNum} listselect ${Window[AAWindow].Child[${ListNum}].List[=${AAName}]}
			/notify AAWindow ${ListNum} leftmouse ${Window[AAWindow].Child[${ListNum}].List[=${AAName}]}
			/notify AAWindow TrainButton leftmouseup
			/delay 1s
			/echo ${Time} Purchased ${AAName} for ${AltAbility[${AAName}].Cost} points.
		}
	/next G
/return 




Sub Event_LootError
	/varset LoreItemError 1
/return

Sub LootItem(string ItemName)
    /declare a int 1
    /declare t int 0
    /declare LootTotal int
    /declare LootSlot int
    /declare lootleft int 0
    /declare LootTimeout timer 1m

    /loot

    |/delay 5s ${Me.State.Equal[BIND]}
    |/if (${Me.State.NotEqual[BIND]}) /return

    /delay 2s

    /if (${Corpse.Items} <= 0) /goto :DoneLooting

    /varset LootTotal 0
    :LootLag
    /if (${LootTotal}!=${Corpse.Items}) {
        /varset LootTotal ${Corpse.Items}
        /delay 1s
        /if (${LootTimeout} <= 0) {
            /call to_channel "-- Problem looting, it's taking too long. Aborted."
            /keypress ESC
            /keypress ESC
            /keypress ESC
            /return
        }
        /goto :LootLag
    }

    /call to_channel "-- Looking to loot ${ItemName}"
    /for LootSlot 1 to ${LootTotal}
        /if (${Corpse.Item[${LootSlot}].Name.Find[${ItemName}]}) {
            /call to_channel "-- Looting ${Corpse.Item[${LootSlot}].Name} found in slot ${LootSlot}"
            :LootItem
            /if (${LootTimeout} <= 0) {
                /call to_channel "-- Problem looting, it's taking too long. Aborted."
                /notify LootWnd DoneButton leftmouseup
                /keypress ESC
                /keypress ESC
                /keypress ESC
                /return
            }
			/varset LoreItemError 0
            /itemnotify loot${LootSlot} rightmouseup
            /delay 5 !${Corpse.Item[${LootSlot}].ID}
			/doevents
            /if (!${Corpse.Item[${LootSlot}].ID} || ${LoreItemError}) {
                /next LootSlot
            } else /goto :LootItem
        }
    /next LootSlot

    :DoneLooting

    /notify LootWnd DoneButton leftmouseup
    /delay 2s

/return


Sub PickupItemSingle(string ItemName)

    /declare OpenBag int 0
    /declare BagNumber string

    /if (${FindItem[${ItemName}].ID}) {
        /call to_channel "-- Found ${FindItem[${ItemName}].Name}"
        /if (${FindItem[${ItemName}].InvSlot.Pack}) {
            /varset BagNumber ${FindItem[${ItemName}].InvSlot.Pack}
            /squelch /nomodkey /itemnotify ${BagNumber} rightmouseup
            /delay 1s
            /varset OpenBag 1
        }
        /squelch /nomodkey /ctrlkey /itemnotify ${FindItem[${ItemName}].InvSlot} leftmouseup
        /if (${OpenBag}) {
            /delay 1s
            /squelch /nomodkey /itemnotify ${BagNumber} rightmouseup
        }
    }
/return

Sub PickupItemStack(string ItemName)

    /declare OpenBag int 0
    /declare BagNumber string

    /if (${FindItem[${ItemName}].ID}) {
        /call to_channel "-- Found ${FindItem[${ItemName}].Name}"
        /if (${FindItem[${ItemName}].InvSlot.Pack}) {
            /varset BagNumber ${FindItem[${ItemName}].InvSlot.Pack}
            /squelch /nomodkey /itemnotify ${BagNumber} rightmouseup
            /delay 1s
            /varset OpenBag 1
        }
        /squelch /nomodkey /shiftkey /itemnotify ${FindItem[${ItemName}].InvSlot} leftmouseup
        /if (${OpenBag}) {
            /delay 1s
            /squelch /nomodkey /itemnotify ${BagNumber} rightmouseup
        }
    }
/return


sub FaceDir(string FaceDirection)

        /declare FaceHeading string

        /if (${FaceDirection.Equal[n]})     /varset FaceHeading 0
        /if (${FaceDirection.Equal[nnnne]}) /varset FaceHeading 348
        /if (${FaceDirection.Equal[nnne]})  /varset FaceHeading 337
        /if (${FaceDirection.Equal[nne]})   /varset FaceHeading 326
        /if (${FaceDirection.Equal[ne]})    /varset FaceHeading 315
        /if (${FaceDirection.Equal[nee]})   /varset FaceHeading 303
        /if (${FaceDirection.Equal[neee]})  /varset FaceHeading 292
        /if (${FaceDirection.Equal[neeee]}) /varset FaceHeading 281
        /if (${FaceDirection.Equal[e]})     /varset FaceHeading 270
        /if (${FaceDirection.Equal[seeee]}) /varset FaceHeading 258
        /if (${FaceDirection.Equal[seee]})  /varset FaceHeading 247
        /if (${FaceDirection.Equal[see]})   /varset FaceHeading 236
        /if (${FaceDirection.Equal[se]})    /varset FaceHeading 225
        /if (${FaceDirection.Equal[sse]})   /varset FaceHeading 213
        /if (${FaceDirection.Equal[ssse]})  /varset FaceHeading 202
        /if (${FaceDirection.Equal[sssse]}) /varset FaceHeading 191
        /if (${FaceDirection.Equal[s]})     /varset FaceHeading 180
        /if (${FaceDirection.Equal[ssssw]}) /varset FaceHeading 168
        /if (${FaceDirection.Equal[sssw]})  /varset FaceHeading 157
        /if (${FaceDirection.Equal[ssw]})   /varset FaceHeading 146
        /if (${FaceDirection.Equal[sw]})    /varset FaceHeading 135
        /if (${FaceDirection.Equal[sww]})   /varset FaceHeading 123
        /if (${FaceDirection.Equal[swww]})  /varset FaceHeading 112
        /if (${FaceDirection.Equal[swwww]}) /varset FaceHeading 101
        /if (${FaceDirection.Equal[w]})     /varset FaceHeading 90
        /if (${FaceDirection.Equal[nnnnw]}) /varset FaceHeading 78
        /if (${FaceDirection.Equal[nnnw]})  /varset FaceHeading 67
        /if (${FaceDirection.Equal[nnw]})   /varset FaceHeading 56
        /if (${FaceDirection.Equal[nw]})    /varset FaceHeading 45
        /if (${FaceDirection.Equal[nww]})   /varset FaceHeading 33
        /if (${FaceDirection.Equal[nwww]})  /varset FaceHeading 22
        /if (${FaceDirection.Equal[nwwww]}) /varset FaceHeading 11

        /if (${FaceHeading.Length} > 0 ) {
            /declare sCheck int 0
            /if (!${Me.Standing}) {
                /stand
                /varset sCheck 1
            }
            /face fast heading ${FaceHeading}
            /if (${sCheck} && !${Me.Sitting}) /sit
        }

/return

|---------------------------------------------------------------------
|----
|--    Combat Over List 
|----
|---------------------------------------------------------------------

sub AddCombatOver(string cCommand)
    /declare a int
    /declare NextEntry int

    /for a 1 to ${MaxCombat}
        /if (${CombatOver[${a}].Equal[NULL]}) {
            /varset NextEntry ${a}
            /goto :HaveNext
        }
    /next a
    /call to_channel "-- CombatOver list is full, delete something or edit the source"
    /return
    :HaveNext

    /varset CombatOver[${NextEntry}] ${cCommand}
    /call to_channel "-- Added combat over action: ${cCommand} "
/return

sub ShowCombatOver
    /declare a int
    /for a 1 to ${MaxCombat}
        /if (${CombatOver[${a}].Equal[NULL]}) {
            /if (${a} == 1) /call to_channel "-- No Combat Over Entries Found"
            /return
        }
        /call to_channel "-- ${a} - Action: ${CombatOver[${a}]}"
    /next a
/return

sub DoCombatOver
    /declare a int
    /for a 1 to ${MaxCombat}
        /if (${CombatOver[${a}].Equal[NULL]}) /return
		/call ProcessRequest ${Requestor} "${CombatOver[${a}]}"
    /next a
/return


sub DeleteCombatOver(string EntryNumber)
    /declare a int
    /declare b int

	/if (${EntryNumber.Equal[all]}) {
		/call to_channel "-- Deleting All Combat Over Entries "
		/for a 1 to ${MaxCombat}
			/varset CombatOver[${a}] NULL
		/next a

		/return
		}
			
    /if (!${Int[${EntryNumber}]}) /return

	/call to_channel "-- Deleting Combat Over Entry ${EntryNumber} - Action: ${CombatOver[${EntryNumber}]}"
    /varset CombatOver[${EntryNumber}] NULL

    /for a 1 to ${MaxCombat}
        /varcalc b ${a}+1

        /if (${CombatOver[${a}].Equal[NULL]}) {
            /if (${a} >= 20) {
                /varset CombatOver[${a}] NULL
            } else {
                /varset CombatOver[${a}] ${CombatOver[${b}]}
                /varset CombatOver[${b}] NULL
            }
        }
    /next a
/return





|---------------------------------------------------------------------
|----
|--    Combat List 
|----
|---------------------------------------------------------------------
sub AddCombat(string cType, string StartHP, string StopHP, string MinMana, string cCommand)
    |/echo cType -${cType}-
    |/echo StartHP -${StartHP}-
    |/echo MinMana -${MinMana}-
    |/echo cCommand -${cCommand}-

    /declare a int
    /declare NextEntry int

    /for a 1 to ${MaxCombat}
        /if (${CombatList[${a}].Equal[NULL]}) {
            /varset NextEntry ${a}
            /goto :HaveNext
        }
    /next a

    /call to_channel "-- Combat list is full, delete something or edit the source"
    /return

    :HaveNext

    /varset CombatList[${NextEntry}] ${cType}|${StartHP}|${StopHP}|${MinMana}|${cCommand}
    /varset CombatAction[${NextEntry}] 1
    /if (${cType.Equal[recast]}) {
        /call to_channel "-- Added combat ${cType} will start at ${StartHP}% if you have at least ${MinMana}% mana will recast ${cCommand} until mob is under ${StopHP}%"
    } else {
        /call to_channel "-- Added combat ${cType} will start at ${StartHP}% if you have at least ${MinMana}% mana will do ${cCommand}"
    }
/return

sub CheckCombatList
	|/echo CheckCombatList Timer ${CombatCheck}
    /if (${CombatCheck}) /return
    /if (!${CombatAssist.Length}) /return
    /if (${CombatList[1].Equal[NULL]}) /return

|    /if (${cDebug}) /echo -- Assist is ${CombatAssist}

    /if (!${MobID}) {
        /varset MobID ${Me.GroupAssistTarget.ID}
        /if (${MobID}) /goto :HaveID
        /varset MobID ${Me.GroupMarkNPC[1].ID}
        /if (${MobID}) /goto :HaveID
        /call AssistPlayer ${CombatAssist}
        /varset MobID ${Target.ID}
		/echo CombatCheckList new MobID = ${MobID}
    }
	

    :HaveID
    /declare cType string
    /declare cName string
    /declare a int

    /if (${Spawn[${MobID}].Type.NotEqual[NPC]}) /goto :combat_check_dead


	/if (${Target.ID}!=${MobID} && ${Spawn[id ${MobID}].ID}) /target id ${MobID}
	/delay 5 ${Target.ID}!=${MobID}
	/if ((${CasterMelee} || ${MeleeOn}) && !${Me.Combat} && ${Target.ID})  {
		/echo Turning Attack ON - MobID ${MobID}  Target ${Target} HP:${Target.PctHPs}%
		/attack on
	}
	

|    /target id ${MobID}

    /if (${Target.ID} == ${Me.ID} || !${Target.ID}) {

        |/echo --++ I am ${Me.ID} -- Mob is ${MobID} -  ${Spawn[${MobID}].CleanName} -- ${Spawn[${MobID}].PctHPs}
		|/echo Me == mob? 
        /varset MobID 0
        /varset DotRecastList
        /varset InCombat 0
        /for a 1 to ${MaxCombat}
            /varset CombatAction[${a}] 1
        /next a
        /varset DotRecastList
        /if (${AnchorReturnEndCombat}) /varset mcsAnchorRun 1
        /squelch /target clear
        /return
    }

    /if (${cDebug}) /echo --++ I am ${Me.ID} -- Mob is ${MobID} -  ${Spawn[${MobID}].CleanName} -- ${Spawn[${MobID}].PctHPs}
    /declare HasOne int 0
    /if (${Me.Combat}) /varset HasOne 1
    /for a 1 to ${MaxCombat}
        /if (${cDebug}) /echo Num ${a} - Action ${CombatAction[${a}]} - MobHP ${Spawn[${MobID}].PctHPs}(${MobID}) - Mana ${Me.PctMana}
		|/echo Num ${a} - Action ${CombatAction[${a}]} - MobHP ${Spawn[${MobID}].PctHPs} MobID (${MobID}) - Mana ${Me.PctMana}
        /if (${CombatList[${a}].NotEqual[NULL]} && ${CombatAction[${a}]}) {
            /if (${CombatAction[${a}]} || ${Me.Combat}) /varset HasOne 1
            |/echo "-- ${a} - Type: ${CombatList[${a}].Arg[1,|]} - Start: ${CombatList[${a}].Arg[2,|]}% - Stop: ${CombatList[${a}].Arg[3,|]}% - MinMana: ${CombatList[${a}].Arg[4,|]}% - Action: ${CombatList[${a}].Arg[5,|]}"
            /if (${Spawn[${MobID}].PctHPs} <= ${CombatList[${a}].Arg[2,|]} && ${Spawn[${MobID}].PctHPs} > ${CombatList[${a}].Arg[3,|]} && ${Me.PctMana} >= ${CombatList[${a}].Arg[4,|]}) {
|				/echo ELH | Combat threshold - Locking MobIDVar and calling ProcessRequest ${CombatAssist} "${CombatList[${a}].Arg[5,|]}" 
|				/echo ELH | Calling Pequest start: MobID = ${MobID}  TargetID = ${Target.ID}
				/varset MobIDLocked 1
				|/echo /call ProcessRequest ${CombatAssist} "${CombatList[${a}].Arg[5,|]}" 
                /call ProcessRequest ${CombatAssist} "${CombatList[${a}].Arg[5,|]}" 
				/varset MobIDLocked 0
				|/echo ELH | Process Request done : MobID = ${MobID}  TargetID = ${Target.ID}
                /varset CombatAction[${a}] 0
                /varset cType ${CombatList[${a}].Arg[1,|].Lower}
                /varset cName ${CombatList[${a}].Arg[5,|]}
                /if (${cType.Equal[recast]}) {
                    /if (!${Defined[RecastInfo_${cName}_Timer]}) {
                        /declare RecastInfo_${cName}_Timer timer outer
                        /declare RecastInfo_${cName}_StopHP int outer
                        /declare RecastInfo_${cName}_Mana int outer
                    }
                    /call GetDuration "${cName}"
                    /varset RecastInfo_${cName}_Timer ${SpellDuration}s
                    /varset RecastInfo_${cName}_StopHP ${CombatList[${a}].Arg[3,|]}
                    /varset RecastInfo_${cName}_Mana ${CombatList[${a}].Arg[4,|]}
                    /varset DotRecastList ${DotRecastList}${cName}|
                }
				/goto :combat_endphase
            }
        }
    /next a

	
|-- ELH - this section was turning off combat - what is purpose?
|
|    /if (!${HasOne}) {
|        /varset InCombat 0
|        /for a 1 to ${MaxCombat}
|            /varset CombatAction[${a}] 1
|        /next a
|        /varset MobID 0
|        /if (${AnchorReturnEndCombat}) /varset mcsAnchorRun 1
|        /if (${Sticking}) /varset Sticking 0
|        /squelch /stick off
|		/echo HasOne is False - Terminate Combat
|    }

    /declare b int ${DotRecastList.Count[|]}
	
    /if (${b} > 0 ) {
        /for a 1 to ${b}
            /varset cName ${DotRecastList.Token[${a},"|"]}
            |/echo Checking timer for ${cName}
			|/echo RecastInfo_Timer = ${RecastInfo_${cName}_Timer}
            /if (${RecastInfo_${cName}_Timer} == 0 && ${Spawn[${MobID}].PctHPs} >= ${RecastInfo_${cName}_StopHP} && ${Me.PctMana} >= ${RecastInfo_${cName}_Mana}) {
                |/echo Timer RESET
				/varset MobIDLocked 1				
                /call ProcessRequest ${CombatAssist} "${cName}"
				/varset MobIDLocked 0
                /call GetDuration "${cName}"
                /varset RecastInfo_${cName}_Timer ${SpellDuration}s
            }
        /next a
    }

	|/return
	
    |/varset CombatCheck 1s

	:combat_endphase
    /if (${CasterMelee} || ${MeleeOn}) {
        /if (${MobID} && ${Target.ID} != ${MobID} && !${Me.Casting.ID}) {
            /target id ${MobID}
        }
		/if (!${Me.Combat} && ${MobID} && ${Spawn[${MobID}].Type.Equal[NPC]}) {
			/echo :CombatEndphase Turning Attack ON - MobID ${MobID}  Target ${Target} HP:${Target.PctHPs}%
			/echo Turning attack on
			/attack on
		}
        /if (!${Sticking}) {
            /squelch /stick ${MeleeStick}
            /varset Sticking 1
        }
    }

    /if (!${MobID}) {
        |/echo --++-- combat off
        /varset InCombat 0
        /for a 1 to ${MaxCombat}
            /varset CombatAction[${a}] 1
        /next a
        /varset DotRecastList
    }

	:combat_check_dead
    /if (${Spawn[${MobID}].Type.NotEqual[NPC]}) {
        /varset MobID 0
        /varset DotRecastList
        /varset InCombat 0
        /for a 1 to ${MaxCombat}
            /varset CombatAction[${a}] 1
        /next a
        /varset DotRecastList
		/squelch /target clear
		/if (${Me.Combat}) /attack off
        /if (${AnchorReturnEndCombat}) /varset mcsAnchorRun 1
		|/echo MobID != NPC reset combat
    }

/return

sub ShowCombat
    /declare a int
    /for a 1 to ${MaxCombat}
        /if (${CombatList[${a}].Equal[NULL]}) {
            /if (${a} == 1) /call to_channel "-- No Combat Entries Found"
            /return
        }
        /call to_channel "-- ${a} - Type: ${CombatList[${a}].Arg[1,|]} - Start: ${CombatList[${a}].Arg[2,|]}% - Stop: ${CombatList[${a}].Arg[3,|]}% - MinMana: ${CombatList[${a}].Arg[4,|]}% - Action: ${CombatList[${a}].Arg[5,|]}"
    /next a

/return

sub DeleteCombat(string EntryNumber)
    /declare a int
    /declare b int
	/if (${EntryNumber.Equal[all]}) {
		/call to_channel "-- Deleting All Combat Entries "
		/for a 1 to ${MaxCombat}
			/varset CombatList[${a}] NULL
			/varset CombatAction[${a}] 0
		/next a
		/return
		}		

    /if (!${Int[${EntryNumber}]}) /return
    /call to_channel "-- Deleting Combat Entry ${EntryNumber} - Type: ${CombatList[${EntryNumber}].Arg[1,|]} - Start: ${CombatList[${EntryNumber}].Arg[2,|]}% - Stop: ${CombatList[${EntryNumber}].Arg[3,|]}% - MinMana: ${CombatList[${EntryNumber}].Arg[4,|]}% - Action: ${CombatList[${EntryNumber}].Arg[5,|]}"}
    /varset CombatList[${EntryNumber}] NULL

    /for a 1 to ${MaxCombat}
        /varcalc b ${a}+1

        /if (${CombatList[${a}].Equal[NULL]}) {
            /if (${a} >= 20) {
                /varset CombatList[${a}] NULL
            } else {
                /varset CombatList[${a}] ${CombatList[${b}]}
                /varset CombatList[${b}] NULL
            }
        }
        /varset CombatAction[${a}] 0
        |/echo ${a} - ${CombatList[${a}]}
    /next a

/return
| ################################################## End Combat Functions ########################################
| ################################################## Begin WatchHP Functions ########################################
Sub AddToWatchHP(WatchTarget, SpellName, Threshold, Duration)

    /declare tWatchTarget ${WatchTarget}
	/echo Add ${WatchTarget}

    /call GetCorrectTarget ${WatchTarget.Lower}
    /varset WatchTarget ${Macro.Return}

	/echo GetTarget = ${WatchTarget}
    /if (!${WatchTarget}) /return

    |/echo Would add entry for ${WatchTarget} casting ${SpellName} at ${Threshold}%
    /if (!${Defined[W_HP_${WatchTarget}_${SpellName}_Threshold]}) {
        /declare W_HP_${WatchTarget}_${SpellName}_Threshold string outer
        /varset WatchHPList ${WatchHPList}${WatchTarget}_${SpellName}|
        /varset OrigWatchHP ${tWatchTarget}|${SpellName}|${Threshold}|${Duration}#${OrigWatchHP}
    }
    /if (!${Defined[W_HP_${WatchTarget}_${SpellName}_Duration]}) /declare W_HP_${WatchTarget}_${SpellName}_Duration float outer
    /if (!${Defined[W_HP_${WatchTarget}_${SpellName}_RecastTime]}) /declare W_HP_${WatchTarget}_${SpellName}_RecastTime timer outer
    /if (!${Defined[W_HP_${WatchTarget}_${SpellName}_RealName]}) /declare W_HP_${WatchTarget}_${SpellName}_RealName string outer

    /call to_channel "-- Added WatchHP entry for ${tWatchTarget} (id ${WatchTarget}) casting ${SpellName} at ${Threshold}%"

    /varset W_HP_${WatchTarget}_${SpellName}_Threshold ${Threshold}
    /varset W_HP_${WatchTarget}_${SpellName}_Duration ${Duration}
    /varset W_HP_${WatchTarget}_${SpellName}_RecastTime 0s
    /varset W_HP_${WatchTarget}_${SpellName}_RealName ${Spawn[id ${WatchTarget}].CleanName}

    |/echo W_HP_${WatchTarget}_${SpellName}_Threshold ${W_HP_${WatchTarget}_${SpellName}_Threshold}
    |/echo W_HP_${WatchTarget}_${SpellName}_Duration ${W_HP_${WatchTarget}_${SpellName}_Duration}
    |/echo W_HP_${WatchTarget}_${SpellName}_RecastTime ${W_HP_${WatchTarget}_${SpellName}_RecastTime}
    |/echo W_HP_${WatchTarget}_${SpellName}_RealName ${W_HP_${WatchTarget}_${SpellName}_RealName}

    |/echo ${WatchHPList}

/return


||----------------------------------------------------------------------
||-------------   CHECK FOR CLERIC DARB OR SHIELD RDY      -------------
||----------------------------------------------------------------------

sub CheckForDarb
	/varset DarbSpellReady 0
	/varset DarbShieldReady 0
	/if (${Me.AltAbility[${SpellInfo_${DarbSpell}.Token[1,","]}]} > 0 && ${Me.AltAbilityReady[${SpellInfo_${DarbSpell}.Token[1,","]}]}) /varset DarbSpellReady 1
	/if (${FindItem[${DarbShield}].Timer.Ticks}==0) /varset DarbShieldReady 1
/return

||----------------------------------------------------------------------
||-------------   DO SHIELD IF READY OR DARB AA + HEAL
||----------------------------------------------------------------------

sub DoDarbNow
	/if (${DarbShieldReady}) {
		/varset MidDarb 1
        /call Cast "${DarbShield}" item
		/varset MidDarb 0
		/varset DarbTimer 6s
	} else /if (${DarbSpellReady}) {
		/varset MidDarb 1
		/call CastSpell "${DarbSpell}" "blind" 1s
		/varset MidDarb 0
		/varset DarbTimer 6s
		/if (${UseAAHoT} && ${Me.AltAbility[${SpellInfo_${AAHoTName}.Token[1,","]}]} > 0 && ${Me.AltAbilityReady[${SpellInfo_${AAHoTName}.Token[1,","]}]}) {
			/call CastSpell "${AAHoTName}" "blind"
		} else /if (${HealAfterDarb}) {
			/call CastSpell "${DarbGroupHealSpell}" "blind"
		}
	}
/return

||----------------------------------------------------------------------
||-------------   CheckForDarb -- interupt spell cast if needed.
||----------------------------------------------------------------------

sub CheckForDarb

    /if (!${UseDarb}) /return
    /if (${MidDarb}) /return
	/if (${DarbTimer}) /return

    /declare G int
    /declare LowHP int 100
	/declare CurHP int 100

    /for G 0 to ${Group}
		/varset CurHP ${Group.Member[${G}].Spawn.PctHPs}
		/if (${CurHP}==50) /varset CurHP 100
		/if (${Group.Member[${G}].State.Equal[DEAD]}) /varset CurHP 0
        /if (${CurHP} < ${LowHP} && ${CurHP} >=1 && ${Group.Member[${G}].Spawn.Distance} <= 200)  /varset LowHP ${CurHP}
    /next G

    /if (${LowHP} < ${DarbThreshold}) {
		/call IsDarbReady
		/if (${DarbSpellReady} || ${DarbShieldReady}) /call Interrupt
	}
/return

||----------------------------------------------------------------------
||-------------   CheckWatchHPList -- Main function to mess with healing
||----------------------------------------------------------------------

sub CheckWatchHPList
    /if (!${WatchHP}) /return
    /declare G int
    /declare LowHP int 100
	/declare CurHP int 100	

    /if (${UseDarb}) {
        /for G 0 to ${Group}
			/varset CurHP ${Group.Member[${G}].Spawn.PctHPs}
			/if (${CurHP}==50) /varset CurHP 100
			/if (${Group.Member[${G}].State.Equal[DEAD]}) /varset CurHP 0
            /if (${CurHP} < ${LowHP} && ${CurHP} >= 1)  /varset LowHP ${CurHP}
        /next G

        /if (${LowHP} < ${DarbThreshold}) {
			/call CheckForDarb
			/varset CombatCheck 1s			
			/if (${DarbSpellReady} || ${DarbShieldReady}) /call DoDarbNow
        }
    }

	/if (${DoGroupHeal} && ${GroupHealTimer}==0) {
        /varset LowHP 0
		/for G 0 to ${Group}
			/varset CurHP ${Group.Member[${G}].Spawn.PctHPs}
			/if (${CurHP}==50) /varset CurHP 100
			/if (${Group.Member[${G}].State.Equal[DEAD]}) /varset CurHP 0
            /if (${CurHP} < ${GroupHealThresh} && ${CurHP} >= 1) /varcalc LowHP ${LowHP}+1
        /next G

		/if (${LowHP}>1) {
			/call to_channel "-- using group heal"
			/call CastSpell "${GroupHealSpell}" "self" 
			/varset GroupHealTimer ${GroupHealRecast}
			/varset CombatCheck 1s			
		}
	}
			
    /declare a int
    /declare b ${WatchHPList.Count[|]}
	/declare hp int
    /if (${b} == 0 ) /return
    |/echo Checking WatchHP List
    /declare W_HP_Entry string
    /declare W_HP_Name string
    /declare W_HP_ID string
    /declare W_HP_Spell string
	/declare mustTarget int 0
	|/echo WatchHP Pulse -- Checking those under my care --
	
    /for a 1 to ${b}
        /varset W_HP_Entry ${WatchHPList.Token[${a},"|"]}
        /varset W_HP_ID ${W_HP_Entry.Token[1,"_"]}
        /varset W_HP_Spell ${W_HP_Entry.Token[2,"_"]}
        /varset W_HP_Name ${W_HP_${W_HP_ID}_${W_HP_Spell}_RealName}

        /if (${Defined[W_HP_${W_HP_ID}_${W_HP_Spell}_Threshold]}) {
            /if (${Spawn[id ${W_HP_ID}].ID} && ${Spawn[id ${W_HP_ID}].Type.NotEqual[Corpse]}) {
                |/echo Valid Check for ${W_HP_Name} - ${Group.Member[${W_HP_Name}]} - ${W_HP_ID} - ${Me.ID}
				/if (${Group.Member[${W_HP_Name}].ID}) {
					/varset hp ${Spawn[id ${W_HP_ID}].PctHPs}
				} else /if ( ${NetBots[${W_HP_Name}].ID}) {
					/varset hp ${NetBots[${W_HP_Name}].PctHPs}
				} else /if (${Me.XTarget[${W_HP_Name}].ID}) {
					|/echo ${W_HP_Name} is on XTarget - Spawn[${W_HP_ID}].PctHPs valid
					/varset hp ${Spawn[id ${W_HP_ID}].PctHPs}
				} else {
					|/echo No Valid HP Check for ${W_HP_Name} so far -> ${Group.Member[${W_HP_Name}]} - ${W_HP_ID} - ${Me.ID}
					/varset mustTarget 1
					/if (${Group.Member[1].Name.Equal[${W_HP_Name}]}) /varset mustTarget 0
					/if (${Group.Member[2].Name.Equal[${W_HP_Name}]}) /varset mustTarget 0
					/if (${Group.Member[3].Name.Equal[${W_HP_Name}]}) /varset mustTarget 0
					/if (${Group.Member[4].Name.Equal[${W_HP_Name}]}) /varset mustTarget 0
					/if (${Group.Member[5].Name.Equal[${W_HP_Name}]}) /varset mustTarget 0

					/if (${mustTarget}) {
						|/echo Targeting ID ${W_HP_ID} --> ${W_HP_Name}
                        /target id ${W_HP_ID}
                        /delay 5
					}
					/varset hp ${Spawn[id ${W_HP_ID}].PctHPs}
                }
				/if (${hp}==50) /varset hp 100
				
                /if (${hp} <= ${W_HP_${W_HP_ID}_${W_HP_Spell}_Threshold} && ${hp} > 0) {
                    /if (${W_HP_${W_HP_ID}_${W_HP_Spell}_RecastTime} <= 0) {
                        /echo ${W_HP_Name} needs a heal, casting ${W_HP_Spell}
						/echo /call CastSpell "${W_HP_Spell}" "${W_HP_Name}" "once"
						/call CastSpell "${W_HP_Spell}" "${W_HP_Name}" "once"
						/if ( ${castReturn.Equal[CAST_SUCCESS]} ) /varset W_HP_${W_HP_ID}_${W_HP_Spell}_RecastTime ${W_HP_${W_HP_ID}_${W_HP_Spell}_Duration}s
						/varset CombatCheck 1s									
                    }
                }
            }
        }
    /next a
/return

sub ShowWatchHP
    /declare a int
    /declare b ${WatchHPList.Count[|]}
    /if (${b} == 0 ) /return
    |/echo Checking WatchHP List
    /declare W_HP_Entry string
    /declare W_HP_Name string
    /declare W_HP_Spell string

    /for a 1 to ${b}
        /varset W_HP_Entry ${WatchHPList.Token[${a},"|"]}
        /varset W_HP_Name ${W_HP_Entry.Token[1,"_"]}
        /varset W_HP_Spell ${W_HP_Entry.Token[2,"_"]}
        /call to_channel "-- ${a} - Name: ${W_HP_${W_HP_Name}_${W_HP_Spell}_RealName} (${W_HP_Name}) -  Spell: ${W_HP_Spell} - Threshold: ${W_HP_${W_HP_Name}_${W_HP_Spell}_Threshold}% - CheckAfter: ${W_HP_${W_HP_Name}_${W_HP_Spell}_Duration}s"
    /next a
/return


sub ResetWatchHP
    /declare a int
    /declare tmpList string
    /declare tmp

/return

    /varset tmpList ${OrigWatchHP}
    /declare b ${tmpList.Count[#]}
    /if (${b} == 0) /return
    /varset OrigWatchHP

    /call DeleteWatchHP -1

    /for a 1 to ${b}
        /varset tmp ${tmpList.Token[${a},"#"]}
        /echo resetting AddToWatchHP ${tmp.Token[1,"|"]} ${tmp.Token[2,"|"]} ${tmp.Token[3,"|"]} ${tmp.Token[4,"|"]}
        /call AddToWatchHP ${tmp.Token[1,"|"]} ${tmp.Token[2,"|"]} ${tmp.Token[3,"|"]} ${tmp.Token[4,"|"]}
    /next a

/return

sub DeleteWatchHP(int EntryID)
    /declare a int
    /declare b ${WatchHPList.Count[|]}
    /if (${b} == 0 ) /return

    /declare tmpList string
    /declare W_HP_Entry string
    /declare W_HP_Name string
    /declare W_HP_Spell string

    /for a 1 to ${b}
        /varset W_HP_Entry ${WatchHPList.Token[${a},"|"]}
        /if (${a} == ${EntryID} || ${EntryID} == -1) {
            /varset W_HP_Name ${W_HP_Entry.Token[1,"_"]}
            /varset W_HP_Spell ${W_HP_Entry.Token[2,"_"]}
            /call to_channel "-- Entry ${EntryID} deleted for ${W_HP_Name} (${W_HP_Spell})"
            /deletevar W_HP_${W_HP_Name}_${W_HP_Spell}_Threshold
            /deletevar W_HP_${W_HP_Name}_${W_HP_Spell}_Duration
            /deletevar W_HP_${W_HP_Name}_${W_HP_Spell}_RecastTime
        } else {
            /varset tmpList ${tmpList}${W_HP_Entry}|
        }
    /next a

    /varset WatchHPList ${tmpList}
/return

| ################################################## End WatchHP Functions ########################################
| ################################################## Begin Recast Functions ########################################
sub AddToRecastList(string tSpellTarget, string tSpellName, int addNow)

    |/echo Adding ${tSpellName} on ${tSpellTarget} to recast list
    /if (!${Defined[Recast_${tSpellTarget}_${tSpellName}_RecastTime]}) {
        /declare Recast_${tSpellTarget}_${tSpellName}_RecastTime timer outer
    }
    /varset RecastList ${RecastList}Recast_${tSpellTarget}_${tSpellName}_RecastTime|
    /declare RecastDuration int ${SpellDuration}
    |/echo Duration ${SpellDuration}
    /if (${SpellDuration} <= 300) {
        /varset RecastDuration ${Math.Calc[${SpellDuration} - 6]}
    } else /if (${SpellDuration} <= 1800) {
        /varset RecastDuration ${Math.Calc[${SpellDuration} - 18]}
    } else {
        /varset RecastDuration ${Math.Calc[${SpellDuration} - 30]}
    }


    /if (${addNow}) {
        |/echo Normal cast, adding to recast
    } else {
        /call to_channel "-- Spell not ready, need to queue this request"
        /varset RecastDuration 60
    }

    /echo RecastDuration ${RecastDuration}

    /varset Recast_${tSpellTarget}_${tSpellName}_RecastTime ${RecastDuration}s

/return

Sub CheckRecasts
    /if (!${WantToRecast}) /return
    /if (${InCombat} && !${CombatRecast}) /return
    /declare a int
    /declare b ${RecastList.Count[|]}
	/declare SpellName string inner
	/declare tID int

	/if (${Me.Invis}) /return

    /if (${Me.Class.ShortName.Equal[WIZ]} && ${DoHarvest}) {
        /if (${Me.PctMana} <= ${HarvestMana} && ${Me.AltAbility[Harvest of Druzzil]} > 0 && ${Me.AltAbilityReady[Harvest of Druzzil]}) /alt activate 172
        /if (${Me.PctMana} <= ${HarvestMana} && ${Me.SpellReady[Harvest]} ) /call cast Harvest
    }

    /if (${b} == 0 ) /return
    |/echo Checking Recast List
    /declare Recast_Entry string
    /declare Recast_Name string
    /declare Recast_Spell string

    /for a 1 to ${b}
        /varset Recast_Entry ${RecastList.Token[${a},"|"]}
        /varset Recast_Name ${Recast_Entry.Token[2,"_"]}
        /varset Recast_Spell ${Recast_Entry.Token[3,"_"]}

        /if (${Defined[Recast_${Recast_Name}_${Recast_Spell}_RecastTime]}) {
		    /varset SpellFullName ${SpellInfo_${Recast_Spell}.Token[1,","]}
			/varset SpellGem ${SpellInfo_${Recast_Spell}.Token[4,","]}

			/varset  SpellName ${SpellFullName}
			/if ( ${SpellGem}==-1 )  {
				/varset SpellName ${FindItem[${SpellFullName}].Spell}
			}
|**
			|-- Check to see if buff is down and recast time > 5sec 
			/if ( ${Me.Buff[${SpellName}].ID}==0 && ${Me.Song[${SpellName}].ID}==0 && ${Recast_${Recast_Name}_${Recast_Spell}_RecastTime} > 50) {
				/if (${SpellGem}>0 && ${Me.Spell[${SpellName}].Ready}
				&& ${FindItem[${SpellFullName}].Timer}==0 &&  ) {
			
			/if ( ${Me.Buff[${SpellName}].ID}==0 && ${Me.Song[${SpellName}].ID}==0 && ${FindItem[${SpellFullName}].Timer}==0 && ${Recast_${Recast_Name}_${Recast_Spell}_RecastTime} > 50 ) {
				/echo cutting recast time to zero on ${Recast_Spell}
				/varset Recast_${Recast_Name}_${Recast_Spell}_RecastTime 5s
			}
**|
            /call GetCorrectTarget "${Recast_Name}"
			/varset tID ${Spawn[${Macro.Return}].ID}
			/if ( ${Recast_Name.Equal[blind]} ) /varset tID ${Me.ID}
			/if ( ${Spawn[id ${tID}].Type.NotEqual[CORPSE]} && ${Spawn[id ${tID}].Distance} < 100 && ${Recast_${Recast_Name}_${Recast_Spell}_RecastTime} <= 0) {
                /call to_channel "-- Recasting ${Recast_Spell} on ${Recast_Name}"
                /varset DoingRecast 1
                /call CastSpell "${Recast_Spell}" "${Recast_Name}"
                /varset DoingRecast 0

                /if (${CastSuccess}) {
                    /varset Recast_${Recast_Name}_${Recast_Spell}_RecastTime ${SpellDuration}s
					|/echo will recast ${Recast_Spell} in ${SpellDuration}s
                } else {
                    /varset Recast_${Recast_Name}_${Recast_Spell}_RecastTime 10s
                }
            }
        }
    /next a

/return

sub ShowRecasts
    /declare a int
    /declare b ${RecastList.Count[|]}
    /if (${b} == 0 ) {
        /call to_channel "-- There are no recast entries"
        /return
    }
    |/echo Showing Recast List
    /declare Recast_Entry string
    /declare Recast_Name string
    /declare Recast_Spell string


    /for a 1 to ${b}
        /varset Recast_Entry ${RecastList.Token[${a},"|"]}
        /varset Recast_Name ${Recast_Entry.Token[2,"_"]}
        /varset Recast_Spell ${Recast_Entry.Token[3,"_"]}

        |/echo Recast_Entry ${Recast_Entry}
        |/echo Recast_Name ${Recast_Name}
        |/echo Recast_Spell ${Recast_Spell}

        /if (${Defined[Recast_${Recast_Name}_${Recast_Spell}_RecastTime]}) {
            /call to_channel "-- ${a} - Name: ${Recast_Name} - Spell: ${Recast_Spell} - Time Until Recast: ${Math.Calc[${Recast_${Recast_Name}_${Recast_Spell}_RecastTime} / 10]}s"
        }
    /next a

/return

sub DeleteRecast(int EntryID)
    /declare a int
    /declare b ${RecastList.Count[|]}
    /if (${b} == 0 ) /return
    |/echo Showing Recast List
    /declare Recast_Entry string
    /declare tmpList string

    /for a 1 to ${b}
        /varset Recast_Entry ${RecastList.Token[${a},"|"]}
        /if (${a} == ${EntryID} || ${EntryID} == -1) {
        } else {
            /varset tmpList ${tmpList}${Recast_Entry}|
        }
    /next a

    /varset RecastList ${tmpList}

/return
| ################################################## Begin Recast Functions ########################################

Sub GetDuration(SpellName)
	/declare ReuseTime float
    /varset SpellFullName ${SpellInfo_${SpellName}.Token[1,","]}
	/varset SpellGem ${SpellInfo_${SpellName}.Token[4,","]}
    /declare tID int ${Spell[${SpellFullName}].ID}
    /varset SpellDuration 0
	|/echo GetDuration for SpellName = ${SpellName}
    |/echo SpellFullName ${SpellFullName}
    |/echo SpellGem ${SpellGem}
    |/echo ${tID}
    |/echo BuffDurationFocus ${BuffDurationFocus}

	/if (${SpellGem} > 0) {
		/if (${Spell[${SpellFullName}].SpellType.Equal[Detrimental]}) {
			/varset SpellDuration ${Math.Calc[${Spell[${SpellFullName}].Duration} * 6 - 6]}
		} else {
			/varset SpellDuration ${Math.Calc[${Spell[${SpellFullName}].Duration} * 6 * ${BuffDurationFocus}]}
		}
		/varset ReuseTime     ${Spell[${SpellFullName}].RecastTime}
	}
	/if (${SpellGem} == 0) {
		/varset SpellDuration ${Math.Calc[${AltAbility[${SpellFullName}].Spell.Duration}*6]}
		/varset ReuseTime     ${Math.Calc[${AltAbility[${SpellFullName}].MyReuseTime}]}
		/if (${SpellFullName.Equal[Elemental Form: Water]}) /varset SpellDuration 2100
	}
	/if (${SpellGem} == -1) { 
		/varset ReuseTime     ${FindItem[${SpellFullName}].TimerReady}
		/varset SpellDuration ${Math.Calc[ ${Spell[${FindItem[${SpellFullName}].Spell}].Duration} * 6]}
	}

	|/echo GetDuration for ${SpellName} Duration ${SpellDuration} vs reuse ${ReuseTime}
	/if (${ReuseTime} > ${SpellDuration}) /varset SpellDuration ${ReuseTime}

    /if (${tID} == 4886) /varset SpellDuration ${Math.Calc[360 * ${BuffDurationFocus}]}


    |/echo SpellDuration ${SpellDuration}
/return


Sub PreCastSpell(SpellName)
    /varset SpellFullName ${SpellInfo_${SpellName}.Token[1,","]}
    /if (${SpellFullName.Equal[NULL]}) /return
    /varset SpellTextBeforeCast ${SpellInfo_${SpellName}.Token[2,","]}
    /varset SpellTextAfterCast ${SpellInfo_${SpellName}.Token[3,","]}
    /varset SpellGem ${SpellInfo_${SpellName}.Token[4,","]}
    /varset Recast ${SpellInfo_${SpellName}.Token[5,","]}
    /varset RecastIfResisted ${SpellInfo_${SpellName}.Token[6,","]}
    /varset AssistType ${SpellInfo_${SpellName}.Token[7,","].Lower}

    /if (${SpellGem} == 0) {
        /varset SpellType alt
        /varset SpellID ${Me.AltAbility[${SpellFullName}].Spell.ID}
        /if (${SpellFullName.Equal[Elemental Form: Water]}) /varset SpellID 62
		/varset SpellRange ${Me.AltAbility[${SpellFullName}].Spell.MyRange}
		/varset SpellReady ${Me.AltAbilityReady[${SpellFullName}]}
    }

    /if (${SpellGem} > 0) {
        /varset SpellType gem${SpellGem}
		/varset SpellID ${Me.Book[${Me.Book[${SpellFullName}]}].ID}
		/varset SpellRange ${Spell[${SpellID}].MyRange}
		/varset SpellReady ${Me.SpellReady[${SpellFullName}]}
        /if (${Me.CurrentMana} < ${Spell[${SpellID}].Mana}) {
			/varset SpellReady 0
            /return
        }
    }

    /if (${SpellGem} == -1) {
        /varset SpellType item
        /varset SpellID ${Spell[${FindItem[${SpellFullName}].Spell}].ID}
		/varset SpellRange ${Spell[${FindItem[${SpellFullName}].Spell}].MyRange}
		/varcalc SpellReady ${FindItem[${SpellFullName}].TimerReady}==0
    }

    /if (${SpellGem} == -2) {
        /varset SpellType disc
		/varset SpellID    ${Me.CombatAbility[${SpellFullName}]}
		/varset SpellRange ${Me.CombatAbility[${SpellID}].MyRange}
		/varset SpellReady ${Me.CombatAbilityReady[${SpellID}]}
    }
/return



Sub CastSpellIfMemmed(SpellName, SpellTarget, doRepeat)
    /varset SpellFullName ${SpellInfo_${SpellName}.Token[1,","]}

	/if (${Me.Gem[${SpellFullName}]}) {
		/echo /call CastSpell "${SpellName}" "${SpellTarget}" "${doRepeat}"
		/call CastSpell "${SpellName}" "${SpellTarget}" "${doRepeat}"
	}
/return


Sub CastSpell(SpellName, SpellTarget, doRepeat)
    /declare RecastAttempts int 0
    /declare WTime int 0
    /varset CastSuccess 0
    /declare IsGroupSpell int 0
    /varset SpellFullName ${SpellInfo_${SpellName}.Token[1,","]}
    /if (${SpellFullName.Equal[NULL]}) /return
    /varset SpellTextBeforeCast ${SpellInfo_${SpellName}.Token[2,","]}
    /varset SpellTextAfterCast ${SpellInfo_${SpellName}.Token[3,","]}
    /varset SpellGem ${SpellInfo_${SpellName}.Token[4,","]}
    /varset Recast ${SpellInfo_${SpellName}.Token[5,","]}
    /varset RecastIfResisted ${SpellInfo_${SpellName}.Token[6,","]}
    /varset AssistType ${SpellInfo_${SpellName}.Token[7,","].Lower}
    /declare tOut string

	|/echo CastSpell(${SpellName}, ${SpellTarget}, ${doRepeat}) Current Target = ${Target}
    |/echo AllInfo ${SpellInfo_${SpellName}}
    |/echo SpellFullName ${SpellFullName}
    |/echo SpellTextBeforeCast ${SpellTextBeforeCast}
    |/echo SpellTextAfterCast ${SpellTextAfterCast}
    |/echo SpellGem ${SpellGem}
    |/echo Recast ${Recast}
    |/echo RecastIfResisted ${RecastIfResisted}
    |/echo AssistType ${AssistType}
    |/echo SpellTarget ${SpellTarget}
	|/echo SpellTargetType ${SpellTargetType}
	|/echo TargetType ${TargetType}

	/if (${UseOOCNow}) /return

    /if (${Me.Class.ShortName.Equal[BRD]}) {
        /varset tOut 3s
        /squelch /twist off
        /if (${Me.Class.ShortName.Equal[BRD]} && (${SpellTargetType.Equal[Group v1]} || ${SpellTargetType.Equal[Group v2]})) /varset SpellTarget blind
        /if (${SpellTarget.NotEqual[blind]}) {
            /if (${TargetType.Equal[Beneficial]}) /call TargetPlayer ${SpellTarget}
            /if (${TargetType.Equal[Detrimental]}) /call AssistPlayer ${SpellTarget}
        }
        /if (${SpellGem} > 0) {
            /if (!${Me.Standing}) /stand
            /squelch /twist ${SpellGem}
            /return
        }
    }

	/varset GoMSpellName ${SpellFullName} 

    /if (${SpellGem} == 0) {
        /varset SpellType alt
        /varset SpellID ${Me.AltAbility[${SpellFullName}].Spell.ID}
        /if (${SpellFullName.Equal[Elemental Form: Water]}) /varset SpellID 62
		/varset SpellRange ${Me.AltAbility[${SpellFullName}].Spell.MyRange}
		/varset SpellReady ${Me.AltAbilityReady[${SpellFullName}]}
    }

    /if (${SpellGem} > 0) {
        /varset SpellType gem${SpellGem}
		/varset SpellID ${Me.Book[${Me.Book[${SpellFullName}]}].ID}
		/varset SpellRange ${Spell[${SpellID}].MyRange}
		/varset SpellReady ${Me.SpellReady[${SpellFullName}]}
        /if (${Me.CurrentMana} < ${Spell[${SpellID}].Mana}) {
            /call to_channel "-- Not enough mana to cast ${SpellFullName}"
            /return CAST_OUTOFMANA
        }
    }

    /if (${SpellGem} == -1) {
        /varset SpellType item
        /varset SpellID ${Spell[${FindItem[${SpellFullName}].Spell}].ID}
		/varset SpellRange ${Spell[${FindItem[${SpellFullName}].Spell}].MyRange}
		/varcalc SpellReady ${FindItem[${SpellFullName}].TimerReady}==0
    }

    /if (${SpellGem} == -2) {
        /varset SpellType disc
		/varset SpellID    ${Me.CombatAbility[${SpellFullName}]}
		/varset SpellRange ${Me.CombatAbility[${SpellID}].MyRange}
		/varset SpellReady ${Me.CombatAbilityReady[${SpellID}]}
    }

	|/echo Cast ${SpellName} -> ${SpellFullName} --> SpellID = ${SpellID} | Ready = ${SpellReady} | Range = ${SpellRange}

    /if (${Me.Class.ShortName.NotEqual[BRD]}) /varset tOut ${Math.Calc[${Int[${Spell[${SpellID}].MyCastTime}]} + 1]}s
    /declare TargetType string ${Spell[${SpellID}].SpellType}
    /declare SpellTargetType string ${Spell[${SpellID}].TargetType}
	||-- Overide incorrect SpellTargetType for 970 Levitation and 1362 mana flare

    /if (${SpellTargetType.Equal[Group v1]} || ${SpellTargetType.Equal[Group v2]} || ${SpellTargetType.Equal[Group v3]}) /varset IsGroupSpell 1
	/if (${SpellType.Equal[disc]} && ${TargetType.Equal[Beneficial]}) /varset SpellTarget blind


	|/echo SpellRange ${SpellRange}
	|/echo SpellReady ${SpellReady}
    |/echo SpellType ${SpellType}
    |/echo SpellID ${SpellID}
    |/echo SpellRealName ${Spell[${SpellID}].Name}
    |/echo TargetType ${TargetType}

    /if (${AssistType.Equal[assist]}) {
        |/echo Overriding target type, new type is Detrimental
        /varset TargetType Detrimental
    }

    /if (${AssistType.Equal[target]}) {
        |/echo Overriding target type, new type is Beneficial
        /varset TargetType Beneficial
    }

    /if (${AssistType.Equal[corpse]}) {
        /call TargetPlayerCorpse "${SpellTarget}"
		/varset SpellTarget blind
    }

    /if (${TargetType.Find[Beneficial]}) {
        /varset noInterrupt 1
        /if ( ${SpellTargetType.Equal[Self]} && !${SpellFullName.Find[illusion: ]} ) /varset SpellTarget blind
        /if ( ${SpellTargetType.Equal[Pet]} ) /varset SpellTarget pet
        |/echo TargetSpellTarget ${SpellTarget}
		/if ( ${AssistType.NotEqual[Blind]} ) /call TargetPlayer "${SpellTarget}"
    }

    /if (${TargetType.Find[Detrimental]}) {
        /if ( ${SpellTargetType.Equal[PB AE]} ) /varset SpellTarget blind
		/if ( ${MobID} && ${MobIDLocked} ) /varset SpellTarget blind
        |/echo AssistSpellTarget ${SpellTarget}
		/if ( ${AssistType.NotEqual[Blind]} ) /call AssistPlayer "${SpellTarget}"
    }

	/if ( ${SpellRangeCheck} && ${Target.Distance} > ${SpellRange} && ${SpellRange}>0) {
		/echo Target out of range : ${SpellName} -> SpellRange ${SpellRange} < Target Range = ${Target.Distance}
		/delay 5
		/return CAST_OUTOFRANGE
	}


    /if ( ${SpellTextBeforeCast.Length} > 0 && ${SpellText}) {
        /if (${DefaultChat.Left[1].Equal[/]}) {
            /docommand ${DefaultChat} ${SpellTextBeforeCast}
        } else {
            /call to_channel "${SpellTextBeforeCast}"
        }
    }


    /if (${SpellGem} == -2) {
		/if ( ${Me.CombatAbilityReady[${SpellFullName}]} ) {
			/echo /disc ${SpellFullName}
			/disc ${SpellFullName}
			/return CAST_SUCCESS
		}
		/return 
    }

    /call GetDuration "${SpellName}"

    |/echo tOut ${tOut}
    /if (${CasterMelee} && ${Me.Combat}) {
        /squelch /stick off
        /varset Sticking 0
        /delay 2s !${Me.Moving}
    }
    /if (${Me.Combat}) {
        /delay 2s !${Me.Moving}
    }

	/if (${IsFollowing.NotEqual[Null]}) {
        /squelch /afollow pause
        /varset Sticking 0
        /delay 2s !${Me.Moving}		
	}

	
	
	|| Verify Targets - WHP not changing heals
	|/echo TargetSpellTarget ${SpellTarget} vs Target = ${Target}
	
        :Recast
        /varcalc RecastAttempts ${RecastAttempts} + 1
        /if ( ${RecastAttempts} > ${MaxRecasts} ) /goto :FinishedCast

        /if (${UseDarb}) {
            /if (${tOut.Length} == 0) /varset tOut 0
            /call Cast "${SpellFullName}" "${SpellType}" "${tOut}" CheckForDarb
        } else {
			|/echo /call Cast "${SpellFullName}" "${SpellType}" "${tOut}"
			/call Cast "${SpellFullName}" "${SpellType}" "${tOut}"
        }
		||	/echo cast done -> ${Macro.Return}
        /if ( ${Macro.Return.Equal[CAST_SUCCESS]} ) /varset CastSuccess 1
        /if ( ${Macro.Return.Equal[CAST_SUCCESS]} && ${SpellTextAfterCast.Length} > 0 && ${SpellText}) {
            /if (${DefaultChat.Left[1].Equal[/]}) {
                /docommand ${DefaultChat} ${SpellTextAfterCast}
            } else {
                /call to_channel "${SpellTextAfterCast}"
            }
        }
        /if ( ${Macro.Return.Equal[CAST_UNKNOWNSPELL]} ) /call to_channel "-- Unknown Spell ${SpellName}"
        /if ( ${Macro.Return.Equal[CAST_OUTOFMANA]} ) /call to_channel "-- Not enough mana to cast ${SpellFullName}"
        /if ( ${Macro.Return.Equal[CAST_OUTOFRANGE]} ) /call to_channel "-- ${Target.CleanName} is out of range"
        /if ( ${Macro.Return.Equal[CAST_CANNOTSEE]} || ${Macro.Return.Equal[CAST_NOTARGET]}) /call to_channel "-- Can't see ${Target.CleanName}"
        /if ( ${Macro.Return.Equal[CAST_STUNNED]} ) {
            /call to_channel "-- ACK Stunned Recasting"
            /goto :Recast
        }
        /if ( ${Macro.Return.Equal[CAST_TOOK2LONG]} ) /call to_channel "-- Casting ERROR: Spell took to long"
        /if ( ${Macro.Return.Equal[CAST_ABILITYNOTREADY]} ) /call to_channel "-- Ability Not Ready"
        /if ( ${Macro.Return.Equal[CAST_IMMUNE]} ) {
            /call to_channel "-- Target is immune to ${SpellFullName}"
            /varset RecastIfResisted 0
            /return
        }
        /if ( ${Macro.Return.Equal[CAST_LOSTTARGET]} ) /call to_channel "-- ACK I lost my target"
        /if ( ${Macro.Return.Equal[CAST_TOOPOWERFUL]} ) /call to_channel "-- ${SpellFullName} is too powerful for ${SpellTarget}"
        /if ( ${Macro.Return.Equal[CAST_RESISTED]} ) {
            /if (${RecastIfResisted}) {
                /if (${SpellGem} > 0) {
                    /varcalc WTime 10*(${Me.Gem[${SpellGem}].RecastTime}+2.25)
                    /call to_channel "-- ${Target.CleanName} resisted ${SpellFullName} will try again in ${Math.Calc[2.25+${Me.Gem[${SpellGem}].RecastTime}]} seconds"
                    /delay ${WTime}
                } else {
                    /call to_channel "-- ${Target.CleanName} resisted ${SpellFullName} will try again"
                }
                /goto :Recast
            } else {
                /call to_channel "-- ${Target.CleanName} resisted ${SpellFullName}"
            }
        }
    }
    |/echo Return ${Macro.Return}
    |/echo WantToRecast ${WantToRecast}
    |/echo Recast ${Recast}

    /if (${Macro.Return.Equal[CAST_SUCCESS]} && ${WantToRecast} && ${Recast}) {
        /if (${TargetType.Equal[Beneficial]} && ${SpellDuration}) {
            /if (${doRepeat.NotEqual[once]}) /call AddToRecastList "${SpellTarget}" "${SpellName}" 1
        }
    } else {
        |/echo ******************* ****************** ******************
        /if (!${DoingRecast} && ${Macro.Return.NotEqual[CAST_SUCCESS]} && ${WantToRecast} && ${Recast}) {
            /if (${TargetType.Equal[Beneficial]} && ${SpellDuration}) {
                /if (${doRepeat.NotEqual[once]}) /call AddToRecastList "${SpellTarget}" "${SpellName}" 0
            }
        }
    }

    :FinishedCast

	/if (${CasterMelee} && ${Me.Combat}) {
		/if (${MobID} != ${Target.ID}) {
			/target id ${MobID}
			/delay 5 ${Target.ID}!=${MobID}
		}
		/if (${Target.ID} && ${Target.PctHPs} && ${Target.Type.NotEqual[CORPSE]}) {
			/squelch /stick ${MeleeStick}
			/varset Sticking 1
		}
    }

    /if (${SitAfterCast} && ${IsFollowing.Equal[Null]}) /call mySit
    /varset noInterrupt 0

    /if (${Me.Class.ShortName.Equal[WIZ]} && ${Me.Pet.ID}) /squelch /pet get lost
	/if (${IsFollowing.NotEqual[Null]}) {
        /tar ${IsFollowing}
		/squelch /afollow unpause
        /varset Sticking 1
	}


/return ${Macro.Return}


sub mySit

    /varset DoSit 1
    /varset SitTimer ${SitDelay}s

/return

sub DoClericSit
	/if (${Me.CombatState.NotEqual[COMBAT]}) /return
    /if (${Defined[SpellInfo_yaulp]}) {
		/varset DoSit 0
		/declare c1 string
		/varset  c1 ${SpellInfo_yaulp.Token[1,","]}
		/if (${Me.Buff[${c1}]}) /return
		/if (${Me.SpellReady[${c1}]}) /call Cast "${c1}"
	}
/return


Sub GetCorrectTarget(string WhoToTarget)
    /declare c3 string

    /if ( ${WhoToTarget.Equal[mypet]} ) /return ${Spawn[pc ${tRequestor}].Pet.ID}

    /if ( ${WhoToTarget.Equal[pet]} ) /return ${Me.Pet.ID}

    /if ( ${WhoToTarget.Equal[self]} ) /return ${Me.ID}

    /if ( ${WhoToTarget.Find[:]} ) {
        /varset c3 ${WhoToTarget.Arg[1,":"]}
        /return ${Spawn[pc ${c3}].Pet.ID}
    }

    /if (${Spawn[pc ${WhoToTarget}].ID}) /return ${Spawn[pc ${WhoToTarget}].ID}
    /if (${Spawn[corpse ${WhoToTarget}].ID}) /return ${Spawn[corpse ${WhoToTarget}].ID}
	/if (${Spawn[mercenary ${WhoToTarget}].ID}) /return ${Spawn[mercenary ${WhoToTarget}].ID}

    /return 0
/return


Sub TargetPlayerCorpse(string WhoToTarget)
    |/echo WhoToTarget ${WhoToTarget}
    /if (${WhoToTarget.Equal[blind]}) /return

    /if (${Spawn[corpse ${WhoToTarget}].ID}) /target id ${Spawn[corpse ${WhoToTarget}].ID}
/return


Sub TargetPlayer(string WhoToTarget)
    |/echo WhoToTarget ${WhoToTarget}
    /if (${WhoToTarget.Equal[blind]}) /return

    /if (${WhoToTarget.Equal[mypet]} || ${WhoToTarget.Equal[pet]} || ${WhoToTarget.Find[:]} || ${WhoToTarget.Equal[self]} ) {
        /call GetCorrectTarget "${WhoToTarget}"
        /target id ${Macro.Return}
    } else {
        /if (${Spawn[corpse ${WhoToTarget}].ID}) /target id ${Spawn[corpse ${WhoToTarget}].ID}
        /if (${Spawn[pc ${WhoToTarget}].ID}) /target id ${Spawn[pc ${WhoToTarget}].ID}
		/if (${Spawn[mercenary ${WhoToTarget}].ID}) /target id ${Spawn[mercenary ${WhoToTarget}].ID}
        /return
    }
    /delay 7
/return

Sub AssistPlayer(string WhoToAssist)
    /varset WhoToAssist ${WhoToAssist.Lower}
    /declare c3 string

	/if ( ${WhoToAssist.Equal[${Me.Name}]} ) /return
    /if ( ${WhoToAssist.Equal[blind]} ) /return

    /if ( ${WhoToAssist.Equal[mypet]} ) {
        /assist ${Spawn[${tRequestor}].Pet.CleanName}
        /delay 7
        |/call to_channel "-- Assisting ( Your pet (${Spawn[${Requestor}].Pet.CleanName}) ) to target ( ${Target.CleanName} )"
        /return
    }

    /if ( ${WhoToAssist.Equal[pet]} ) {
        /assist ${Me.Pet.CleanName}
        /delay 7
        |/call to_channel "-- Assisting ( My pet (${Me.Pet.CleanName})) to target ( ${Target.CleanName} )"
        /return
    }

    /if ( !${WhoToAssist.Equal[NULL]} ) {
        /if ( ${c2.Find[":"]} ) {
            | They want someone elses pet
            /varset c3 ${c2.Arg[1,":"]}
            /assist ${Spawn[${c3}].Pet.CleanName}
            /delay 7
            |/call to_channel "-- Assisting ( ${c3}'s pet (${Spawn[${Requestor}].Pet.CleanName})) to target ( ${Target.CleanName} )"
            /return
        }
        /assist ${WhoToAssist}
        /delay 7
        |/call to_channel "-- Assisting ( ${WhoToAssist} ) to target ( ${Target.CleanName} )"
        /return
    }

    | There is no target Assist Requestor
    /assist ${tRequestor}
    /delay 7
    |/call to_channel "-- Assisting ( ${tRequestor} ) to target ( ${Target.CleanName} )"

/return

Sub IsValidUser(string thisUser)
    /if (${ValidUsers.Find[,${thisUser.Lower},]}) /return 1
	/varset thisUser anyone
	/if (${ValidUsers.Find[,${thisUser.Lower},]}) /return 1
/return 0

Sub to_channel(string information)
| Sends Generic Message to Channel

    /if ( ${UseDebugForNotify} ) {
        | Send Information to MQ Window
        /echo ${information}
    }

    /if ( ${UseChatForNotify} ) {
        | Send to Channel
        /docommand ${mcsChannel} ${information}
    }

    /if ( ${UseIRCForNotify} ) {
        | Send to Channel
        /squelch /i say ${information}
    }

/return

Sub chatty(string Requestor, string Channel, string Request)
    | Sends to Chat Channel
    /call to_channel "-- ${Requestor} told ${Channel} '${Request}'"
/return

Sub Event_Ignore()
    | Temp
/return

Sub Event_NoFollow()
|    /call to_channel "-- Cannot follow target, does not exist in zone"
/return

Sub Event_Zoned()
    /varset MobID 0
    /varset InCombat 0
    /varset DotRecastList
    /varset DoSit 0
	/varset LastMeID ${Me.ID}
	/varset DoingChain 0
    /squelch twist off
    /keypress forward
    /keypress back
	/squelch /stick off


    /declare a int
    /for a 1 to ${MaxCombat}
        /varset CombatAction[${a}] 1
    /next a
    /squelch /attack off
    /squelch /target clear

    /delay 1

    /squelch twist off

    /if (${Me.Class.ShortName.Equal[WIZ]} && ${Me.Pet.ID}) /squelch /pet get lost


    /if ( !${IsFollowing.Equal[NULL]} ) {
        /tar ${IsFollowing}
		/squelch /afollow on
        |/squelch /stick hold 10 uw
        /varset Sticking 1
    }

    /if ( ${mcsAnchorY.NotEqual[NULL]} || ${mcsAnchorX.NotEqual[NULL]} ) {
        /call to_channel "-- I just zoned, clearing out Anchor spot"
        /varset mcsAnchorY NULL
        /varset mcsAnchorX NULL
        /varset mcsFacing 0
        /squelch /stick off
        /varset Sticking 0
    }

    /if (${DoMez}) {
        /call to_channel "-- Auto Mezzing *OFF*"
        /varset DoMez 0
    }

    /if (${OffTank}) {
        /varset OffTank 0
        /call to_channel "-- Off Tanking *OFF*"
    }

    /squelch twist off

    /if (${doOnZone.Length} > 0) {
        /call to_channel "-- Executing ${doOnZone}"
        /docommand ${doOnZone}
    }

    /varset doOnZone

    /if (${MemSpells}) {
        /delay 5
        /delay 5
        /call to_channel "-- AutoMemming set ${AutoMemSetName}"
        /varset MemSpells 0
        /memspellset ${AutoMemSetName}
        /delay 22s
    }

    /call ResetWatchHP
	/call PullClearVars

	/varset MezImmuneList ${Ini[mcs_mez.ini,immune,${Zone.Name},^]}
	
/return

Sub Event_Ding()
    /call to_channel "-- Ding ${Me.Level}"
/return

Sub Event_AADing()
    /call to_channel "-- AA Ding ${Me.AAPoints}"
/return

Sub Event_LowDrink()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- Hmmm... I sure could use some more drink."
/return

Sub Event_LowFood()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- How about if I split my last meal with you?"
/return

Sub Event_OutFood()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- Ummm why are you starving me?"
/return

Sub Event_OutDrink()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- What are we in the desert here could you not spare some drink?"
/return

Sub Event_OutFoodLowDrink()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- I am out of food and low on drink."
/return

Sub Event_OutDrinkLowFood()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- I am thirsty and down to my last meal."
/return

Sub Event_LowFoodLowDrink()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- I am down to my last meal and drink."
/return

Sub Event_OutFoodOutDrink()
    /if (${QuietFoodDrink}) /return
    /call to_channel "-- Well you managed to neglect me to the point that I have run out of food and drink."
/return

|| -- Verify profile is good before loading
Sub GetValidProfile 

    /varset SpellList ${Ini[${mcsINI},${MyName}-Spells]}
	/if (${SpellList.Equal[NULL]}) {
		|-- No spell list for toon so its not configured. 

		/varset mcsKeyword			${MyName}
		/varset mcsChannel			${MyName}
		/varset mcsChannelName		${MyName}
		/varset mcsChannelPassword	${MyName}

		/varset MyName Default

		/varset SpellList ${Ini[${mcsINI},Default-Spells]}
		/if (${SpellList.Equal[NULL]}) {
			|-- No Default -- No Spell list. Exit so we don't crash
			/echo ${mcsINI} has no default section, and no profile for ${Me.Name.Lower}. Halting
			/end
		}
			
		/echo ${mcsINI} has no profile for ${Me.Name.Lower} so using Default profile
	}
/return


Sub LoadINI()


    /varset mcsKeyword ${Ini[${mcsINI},${MyName}-configuration,Keyword]}
    /varset mcsChannel ${Ini[${mcsINI},${MyName}-configuration,Channel]}
    /varset mcsChannelName ${Ini[${mcsINI},${MyName}-configuration,Channel]}
    /varset mcsChannelPassword ${Ini[${mcsINI},${MyName}-configuration,ChannelPassword]}

	/call GetValidProfile

    /varset AbortCast ${Ini[${mcsINI},${MyName}-configuration,AbortCast,${AbortCast}]}
    /varset MaxRecasts ${Ini[${mcsINI},${MyName}-configuration,MaxRecasts,${MaxRecasts}]}
    /varset GStatusAnnounce ${Ini[${mcsINI},${MyName}-configuration,GStatusAnnounce,${GStatusAnnounce}]}
    /varset GStatusTimer ${Ini[${mcsINI},${MyName}-configuration,GStatusTimer,${GStatusTimer}]}
    /varset WantToRecast ${Ini[${mcsINI},${MyName}-configuration,WantToRecast,${WantToRecast}]}
    /varset SwitchSpells ${Ini[${mcsINI},${MyName}-configuration,SwitchSpells,${SwitchSpells}]}
    /varset ResendTells ${Ini[${mcsINI},${MyName}-configuration,ResendTells,${ResendTells}]}
    /varset Verbosity ${Ini[${mcsINI},${MyName}-configuration,Verbosity,${Verbosity}]}
    /varset UseDebugForNotify ${Ini[${mcsINI},${MyName}-configuration,UseDebugForNotify,${UseDebugForNotify}]}
    /varset UseChatForNotify ${Ini[${mcsINI},${MyName}-configuration,UseChatForNotify,${UseChatForNotify}]}
    /varset SitAfterCast ${Ini[${mcsINI},${MyName}-configuration,SitAfterCast,${SitAfterCast}]}
    /varset SitDelay ${Ini[${mcsINI},${MyName}-configuration,SitDelay,${SitDelay}]}
    /varset YellWhenHit ${Ini[${mcsINI},${MyName}-configuration,YellWhenHit,${YellWhenHit}]}
    /varset GateWhenHit ${Ini[${mcsINI},${MyName}-configuration,GateWhenHit,${GateWhenHit}]}
    /varset GateSpellName ${Ini[${mcsINI},${MyName}-configuration,GateSpellName,${GateSpellName}]}
    /varset QuitWhenHit ${Ini[${mcsINI},${MyName}-configuration,QuitWhenHit,${QuitWhenHit}]}
    /varset QuitWhenDead ${Ini[${mcsINI},${MyName}-configuration,QuitWhenDead,${QuitWhenDead}]}
    /varset QuitGateThreshold ${Ini[${mcsINI},${MyName}-configuration,QuitGateThreshold,${QuitGateThreshold}]}
    /varset UntargetFirst ${Ini[${mcsINI},${MyName}-configuration,UntargetFirst,${UntargetFirst}]}
    /varset DoForage ${Ini[${mcsINI},${MyName}-configuration,DoForage,${DoForage}]}
    /varset UseNameToCast ${Ini[${mcsINI},${MyName}-configuration,UseNameToCast,${UseNameToCast}]}
    /varset GroupChat ${Ini[${mcsINI},${MyName}-configuration,GroupChat,${GroupChat}]}
    /varset DotAnnounce ${Ini[${mcsINI},${MyName}-configuration,DotAnnounce,${DotAnnounce}]}
    /varset ValidUsers ,${Ini[${mcsINI},${MyName}-configuration,userlist].Lower},
    /varset BuffDurationFocus ${Ini[${mcsINI},${MyName}-configuration,BuffDuration,${BuffDurationFocus}]}
    /varset DefaultChat ${Ini[${mcsINI},${MyName}-configuration,DefaultChat]}
    /varset PetWeaponSpell ${Ini[${mcsINI},${MyName}-configuration,PetWeaponSpell,${PetWeaponSpell}]}
    /varset PetMaskSpell ${Ini[${mcsINI},${MyName}-configuration,PetMaskSpell,${PetMaskSpell}]}
    /varset PetBeltSpell ${Ini[${mcsINI},${MyName}-configuration,PetBeltSpell,${PetBeltSpell}]}
    /varset PetSpellName ${Ini[${mcsINI},${MyName}-configuration,PetSpell,${PetSpell}]}
	/varset UseModRod ${Ini[${mcsINI},${MyName}-configuration,UseModRod,${UseModRod}]}
	/varset AutoAccept ${Ini[${mcsINI},${MyName}-configuration,AutoAccept,${AutoAccept}]}
	/varset SpellRangeCheck ${Ini[${mcsINI},${MyName}-configuration,SpellRangeCheck,${SpellRangeCheck}]}
	/varset AutoAA ${Ini[${mcsINI},${MyName}-configuration,AutoAA,${AutoAA}]}
    /varset DarbThreshold ${Ini[${mcsINI},${MyName}-configuration,DarbThreshold,${DarbThreshold}]}
    /varset DarbGroupHealSpell ${Ini[${mcsINI},${MyName}-configuration,DarbGroupHealSpell,${DarbGroupHealSpell}]}
    /varset DarbSpell ${Ini[${mcsINI},${MyName}-configuration,DarbSpell,${DarbSpell}]}
	/varset DarbShield ${Ini[${mcsINI},${MyName}-configuration,DarbShield,${DarbShield}]}
    /varset UseAAHoT ${Ini[${mcsINI},${MyName}-configuration,UseAAHoT,${UseAAHoT}]}
    /varset AAHoTName ${Ini[${mcsINI},${MyName}-configuration,AAHoTName,${AAHoTName}]}
    /varset HealAfterDarb ${Ini[${mcsINI},${MyName}-configuration,HealAfterDarb,${HealAfterDarb}]}
    /varset UseDarb ${Ini[${mcsINI},${MyName}-configuration,UseDarb,${UseDarb}]}

    /varset MoveBack ${Ini[${mcsINI},${MyName}-configuration,MoveBack,${MoveBack}]}
    /varset MoveSide ${Ini[${mcsINI},${MyName}-configuration,MoveSide,${MoveSide}]}
    /varset MoveDir ${Ini[${mcsINI},${MyName}-configuration,MoveDir,${MoveDir}]}
    /varset MeleeStick ${Ini[${mcsINI},${MyName}-configuration,MeleeStick,${MeleeStick}]}
    
	/varset OwnMaster ${Ini[${mcsINI},${MyName}-configuration,OwnMaster,${OwnMaster}]}


    /echo Valid user list: ${Ini[${mcsINI},${MyName}-configuration,userlist]}

    /varset UseIRC ${Ini[${mcsINI},${MyName}-configuration,UseIRC]}
    /varset IRCServer ${Ini[${mcsINI},${MyName}-configuration,IRCServer]}
    /varset IRCPort ${Ini[${mcsINI},${MyName}-configuration,IRCPort]}
    /varset IRCChannel ${Ini[${mcsINI},${MyName}-configuration,IRCChannel]}

    /varset FoodSpell ${Ini[${mcsINI},${MyName}-configuration,FoodSpell]}
    /varset WaterSpell ${Ini[${mcsINI},${MyName}-configuration,WaterSpell]}
    /varset AutoTrade ${Ini[${mcsINI},${MyName}-configuration,AutoTrade]}
    /varset AutoPetHold ${Ini[${mcsINI},${MyName}-configuration,AutoPetHold]}

    /varset UseGuildChat ${Ini[${mcsINI},${MyName}-configuration,UseGuildChat,${UseGuildChat}]}
    /varset UseGroupChat ${Ini[${mcsINI},${MyName}-configuration,UseGroupChat,${UseGroupChat}]}
    /varset UseChannelChat ${Ini[${mcsINI},${MyName}-configuration,UseChannelChat,${UseChannelChat}]}
    /varset UseRaidChat ${Ini[${mcsINI},${MyName}-configuration,UseRaidChat,${UseRaidChat}]}
    /varset UseTells ${Ini[${mcsINI},${MyName}-configuration,UseTells,${UseTells}]}
    /varset UseIRCChat ${Ini[${mcsINI},${MyName}-configuration,UseIRCChat,${UseIRCChat}]}

    /varset WatchIRC ${Ini[${mcsINI},${MyName}-configuration,WatchIRC,${WatchIRC}]}
    /varset WatchIRCName ${Ini[${mcsINI},${MyName}-configuration,WatchIRCName,${WatchIRCName}]}
    /varset WatchIRCIM ${Ini[${mcsINI},${MyName}-configuration,WatchIRCIM,${WatchIRCIM}]}
    /varset WatchIRCIM2 ${Ini[${mcsINI},${MyName}-configuration,WatchIRCIM2,${WatchIRCIM2}]}
    /varset IMPass ${Ini[${mcsINI},${MyName}-configuration,IMPass,${IMPass}]}

    /if (${IMPass.NotEqual[NOPASS]}) /imconnect ${Me.Name}
    /if (${Debug}) {
        /echo mcsKeyword ${mcsKeyword}
        /echo mcsChannel ${mcsChannel}
        /echo mcsChannelName ${mcsChannelName}
        /echo mcsChannelPassword ${mcsChannelPassword}
        /echo AbortCast ${AbortCast}
        /echo MaxRecasts ${MaxRecasts}
        /echo GStatusAnnounce ${GStatusAnnounce}
        /echo GStatusTimer ${GStatusTimer}
        /echo WantToRecast ${WantToRecast}
        /echo SwitchSpells ${SwitchSpells}
        /echo ResendTells ${ResendTells}
        /echo Verbosity ${Verbosity}
        /echo UseDebugForNotify ${UseDebugForNotify}
        /echo UseChatForNotify ${UseChatForNotify}
        /echo SitAfterCast ${SitAfterCast}
        /echo SitDelay ${SitDelay}
        /echo YellWhenHit ${YellWhenHit}
        /echo GateWhenHit ${GateWhenHit}
        /echo GateSpellName ${GateSpellName}
        /echo QuitWhenHit ${QuitWhenHit}
        /echo QuitWhenDead ${QuitWhenDead}
        /echo QuitGateThreshold ${QuitGateThreshold}
        /echo UntargetFirst ${UntargetFirst}
        /echo DoForage ${DoForage}
        /echo UseNameToCast ${UseNameToCast}
        /echo GroupChat ${GroupChat}
        /echo DotAnnounce ${DotAnnounce}
        /echo ValidUsers ${ValidUsers}
        /echo BuffDurationFocus ${BuffDurationFocus}
        /echo DarbThreshold ${DarbThreshold}
        /echo DarbGroupHealSpell ${DarbGroupHealSpell}
        /echo DarbSpell ${DarbSpell}
		/echo DarbShield ${DarbShield}
        /echo UseAAHoT ${UseAAHoT}
        /echo AAHoTName ${AAHoTName}
        /echo HealAfterDarb ${HealAfterDarb}
        /echo UseDarb ${UseDarb}
        /echo MoveBack ${MoveBack}
        /echo MoveSide ${MoveSide}
        /echo MoveDir ${MoveDir}
		/echo UseModRod ${UseModRod}
    }

	/varset SpellList |
    /call LoadSpells "default"
    /call LoadSpells "${Me.Class.Name.Lower}"
	/call LoadSpells "${MyName}"
		
	/varset MezImmuneList ${Ini[mcs_mez.ini,immune,${Zone.Name},^]}

/return


Sub NewINI()
	/varset  MyName ${Me.Name}
	/varset  mcsINI mcs_${Me.Name}.ini
	
	
	/popup MCS Building new ini file for ${Me.Name} as ${mcsINI}
	/echo  MCS Building new ini file for ${Me.Name} as ${mcsINI}

	/declare a int
	/declare b int
	/declare SpellName string local
	
	/ini "${mcsINI}"	"${MyName}-spells"	"shortname"			"spell name,start message,landed message,gem,recast if worn off?,resist if resisted,assist type"

	|- Dump spells that are loaded 
	/echo Checking spells
	/for a 1 to 20
		/echo /if (${Me.Gem[${a}].ID}) ${a}
		/if (${Me.Gem[${a}].ID}) { 
			/ini "${mcsINI}"	"${MyName}-spells"	"gem${a}"			"${Me.Gem[${a}]},,,${a}"
			/ini "${mcsINI}"	"MQ2Melee-buff"		"downshit${a}"		"/if (!$ {Me.Moving} && !$ {Me.Invis} && !$ {Me.Feigning} && !$ {Me.Sitting} && !$ {Me.AFK} && !$ {Stick.Active} && $ {Spell[${Me.Gem[${a}]}].Stacks} && !$ {Me.Buff[${Me.Gem[${a}]}} && $ {Cast.Ready[${Me.Gem[${a}]}]} && $ {Me.PctMana}>5) /casting "${Me.Gem[${a}]}"
			/ini "${mcsINI}"	"MQ2Melee-atk"		"holyshit${a}"		"/if ($ {Me.Combat} && $ {Target.Type.Equal[NPC]} && $ {Cast.Ready[${Me.Gem[${a}]}]}) /casting ${Me.Gem[${a}]}
			}
	/next a
	|- Dump worn and pack clicky items
	/echo Checking items
	/for a 1 to 32
		/if (${Me.Inventory[${a}].EffectType.Equal[Click Inventory]}) {
			/ini "${mcsINI}"	"${MyName}-spells"	"inv${a}"			"${Me.Inventory[${a}]},,,-1,0,0,blind"
		}
		|-- if its a container check to see whats in it. 
		/if (${Me.Inventory[${a}].Container}) {
			/for b 1 to ${Me.Inventory[${a}].Container} 
				/if (${Me.Inventory[${a}].Item[${b}].EffectType.Equal[Click Inventory]}) {
					/ini "${mcsINI}"	"${MyName}-spells"	"inv${a}_${b}"			"${Me.Inventory[${a}].Item[${b}]},,,-1,0,0,blind"
				}
			/next b
		}
	/next a
	/popup Scanning AA's this will take a few seconds. 
	|- Dump AA with an effect
	/varset a 1
	/varset b 4
	/if (${Window[AAWindow].Child[CanPurchaseFilter].Checked}) {
		/nomodkey /notify AAWindow CanPurchaseFilter leftmouseup 
		/delay 5
	}
	/nomodkey /notify AAWindow AAW_Subwindows tabselect ${b}			
	/delay 5	
	:Loop
	/if (${Window[AAWindow].Child[List${b}].List[${a}].Length}) {
		/nomodkey /notify AAWindow List${b} listselect ${a}	
		/if (${Window[AAWindow].Child[HotButton].Enabled}) {
			/ini "${mcsINI}"	"${MyName}-spells"	"aa${b}_${a}"			"${Window[AAWindow].Child[List${b}].List[${a}, 1]},,,0,0,0,blind"
		}
		/varcalc a ${a}+1
		/goto :Loop
	}
	/if (${b}>1) {
		/varcalc b ${b}-1
		/varset a 1
		/nomodkey /notify AAWindow AAW_Subwindows tabselect ${b}	
		/delay 5
		/goto :Loop
	}
	|- Dump Discs
	/for a 1 to 8
		/echo (${Window[CombatAbilityWnd].Child[CAW_Button${a}].Text.Length}) a = CAW_Button${a}
		/if (${Window[CombatAbilityWnd].Child[CAW_Button${a}].Text.Length}) {
			/varset SpellName ${Window[CombatAbilityWnd].Child[CAW_Button${a}].Text}
			/ini "${mcsINI}"	"${MyName}-spells"	"disc${a}"	"${SpellName},,,-2,0,0,blind"
			/ini "${mcsINI}"	"MQ2Melee-FLAG"		"holyflag${a}"	"0"
			/ini "${mcsINI}"	"MQ2Melee-DISC"		"holyshit${a}"	"/if (!$ {Melee.DiscID} && $ {Me.PctEndurance} > 25 && ${Me.CombatAbilityReady[${SpellName}]}) /disc ${SpellName}
		}
	/next a


	/ini "${mcsINI}"	"${MyName}-configuration" 	"Keyword" 			"${mcsKeyword}"
    /ini "${mcsINI}"	"${MyName}-configuration" 	"Channel" 			"${mcsChannel}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"Channel"			"${mcsChannelName}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"ChannelPassword"	"${mcsChannelPassword}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"AbortCast"			"${AbortCast}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"MaxRecasts"		"${MaxRecasts}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"GStatusAnnounce"	"${GStatusAnnounce}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"GStatusTimer"		"${GStatusTimer}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"WantToRecast"		"${WantToRecast}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"SwitchSpells"		"${SwitchSpells}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"ResendTells"		"${ResendTells}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"Verbosity"			"${Verbosity}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseDebugForNotify"	"${UseDebugForNotify}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseChatForNotify"	"${UseChatForNotify}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"SitAfterCast"		"${SitAfterCast}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"SitDelay"			"${SitDelay}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"YellWhenHit"		"${YellWhenHit}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"GateWhenHit"		"${GateWhenHit}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"GateSpellName"		"${GateSpellName}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"QuitWhenHit"		"${QuitWhenHit}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"QuitWhenDead"		"${QuitWhenDead}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"QuitGateThreshold"	"${QuitGateThreshold}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UntargetFirst"		"${UntargetFirst}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"DoForage"			"${DoForage}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseNameToCast"		"${UseNameToCast}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"GroupChat"			"${GroupChat}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"DotAnnounce"		"${DotAnnounce}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UserList"			
    /ini "${mcsINI}"	"${MyName}-configuration"	"BuffDuration"		"${BuffDurationFocus}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"DefaultChat"		
    /ini "${mcsINI}"	"${MyName}-configuration"	"PetWeaponSpell"	"${PetWeaponSpell}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"PetMaskSpell"		"${PetMaskSpell}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"PetBeltSpell"		"${PetBeltSpell}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"PetSpell"			"${PetSpell}"
	/ini "${mcsINI}"	"${MyName}-configuration"	"UseModRod"			"${UseModRod}"
	/ini "${mcsINI}"	"${MyName}-configuration"	"AutoAccept"		"${AutoAccept}"
	/ini "${mcsINI}"	"${MyName}-configuration"	"SpellRangeCheck"	"${SpellRangeCheck}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"DarbThreshold"		"${DarbThreshold}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"DarbGroupHealSpell"	"${DarbGroupHealSpell}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"DarbSpell"			"${DarbSpell}"
	/ini "${mcsINI}"	"${MyName}-configuration"	"DarbShield"		"${DarbShield}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseAAHoT"			"${UseAAHoT}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"AAHoTName"			"${AAHoTName}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"HealAfterDarb"		"${HealAfterDarb}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseDarb"			"${UseDarb}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"MoveBack"			"${MoveBack}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"MoveSide"			"${MoveSide}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"MoveDir"			"${MoveDir}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"MeleeStick"		"${MeleeStick}"
	/ini "${mcsINI}"	"${MyName}-configuration"	"OwnMaster"			"${OwnMaster}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseIRC"			1
    /ini "${mcsINI}"	"${MyName}-configuration"	"IRCServer"
    /ini "${mcsINI}"	"${MyName}-configuration"	"IRCPort"
    /ini "${mcsINI}"	"${MyName}-configuration"	"IRCChannel"
    /ini "${mcsINI}"	"${MyName}-configuration"	"FoodSpell"
    /ini "${mcsINI}"	"${MyName}-configuration"	"WaterSpell"
    /ini "${mcsINI}"	"${MyName}-configuration"	"AutoTrade"
    /ini "${mcsINI}"	"${MyName}-configuration"	"AutoPetHold"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseGuildChat"		"${UseGuildChat}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseGroupChat"		"${UseGroupChat}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseChannelChat"	"${UseChannelChat}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseRaidChat"		"${UseRaidChat}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseTells"			"${UseTells}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"UseIRCChat"		"${UseIRCChat}"

    /ini "${mcsINI}"	"${MyName}-configuration"	"WatchIRC"			"${WatchIRC}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"WatchIRCName"		"${WatchIRCName}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"WatchIRCIM"		"${WatchIRCIM}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"WatchIRCIM2"		"${WatchIRCIM2}"
    /ini "${mcsINI}"	"${MyName}-configuration"	"IMPass"			"${IMPass}"

	/end
/return



Sub Event_eDotAnnounce(string line, string spelloff)
    /if ( ${DotAnnounce} ) /call to_channel "-- My ${spelloff} just wore off!"
/return

Sub Event_GetChannel(string line)
    /declare c2 string
    /declare a int

    /if ( !${line.Mid[${Math.Calc[${line.Find[${mcsChannelName}]}-2]},1]} ) {
        /echo Could not find channel defaulting to ${DefaultChat}
        /varset mcsChannel ${DefaultChat}
        /return
    }

    /varset mcsChannel "/${line.Mid[${Math.Calc[${line.Find[${mcsChannelName}]}-2]},1]}"
    /delay 1s
    /call to_channel "-- Using Channel ${mcsChannel} for communication"

/return

Sub Forage()
    /declare a int

    /if ( ${Me.AbilityReady[Forage]}) {
        /varset a 0
        /if (!${Me.Standing}) {
            /stand
            /varset a 1
        }
        /if (!${Me.Casting.ID}) {
            /delay 1s
            /doability Forage
            /delay 1s
            :ForageInv
            /if ( ${Cursor.ID} ) {
                | Will keep putting in inventory until cursor is free
                /delay 1s
				/cursor check
                /autoinv
                /delay 1s
                /goto :ForageInv
            }
        }
        /if ( ${a} ) /sit
    }

/return

Sub Event_NospellSet()
    /call to_channel "-- No Such spell set exists"
/return

Sub Event_WhereBound(string line, string name)
    /call to_channel "-- I am currently bound in ${name}"
/return

Sub ListSpellsMem()
    /declare a int
    /declare c3 string

    /for a 1 to 9
    /varset c3 ${Me.Gem[${a}]}
    /if ( ${c3.Equal[NULL]} ) {
        /call to_channel "-- ${a}: No spell"
    } else {
        /call to_channel "-- ${a}: <spell> - ${Me.Gem[${a}]}"
    }

    /next a
/return

Sub HelpSystem(string Request, string helper)
    /declare a int
    /declare c1 string
    /declare c2 string
    /declare c3 string

    /if ( ${helper.Equal[NULL]} ) {
        | They think they want a full list of Commands tell them about it!
        /call to_channel "-- For a full list of commands type 'help YES' as it is quite spammy!"
        /return
    }

    /if ( ${helper.Equal[YES]} ) {
        | They want a full list of Commands
        /call to_channel "-- target [PLAYER]    | target [PLAYER:pet]       | target [mypet]"
        /call to_channel "-- target [pet]       | assist [PLAYER]           | assist [PLAYER:pet]"
        /call to_channel "-- assist [mypet]     | assist [pet]              | untarget"
        /call to_channel "-- targethp           | mem set [SETNAME]         | mem list"
        /call to_channel "-- demem [GEMSLOT]    | mypet                     | pet attack"
        /call to_channel "-- pet guardme        | pet guardhere             | pet follow"
        /call to_channel "-- pet backoff        | pet taunton               | pet tauntoff"
        /call to_channel "-- pet hold           | pet sit                   | pet stand"
        /call to_channel "-- pet feign          | pet focus                 | pet nocast"
        /call to_channel "-- forage [ON]        | forage [OFF]              | forage [ONCE]"
        /call to_channel "-- hp                 | mana                      | group join"
        /call to_channel "-- group join [TARGET]| group disband             | group list"
        /call to_channel "-- group makeleader   | group makeleader [TARGET] | consent"
        /call to_channel "-- consent [TARGET]   | wherebound                | click yes"
        /call to_channel "-- click trade        | follow [PLAYER]           | stopfollow"
        /call to_channel "-- sit                | med                       | stand"
        /call to_channel "-- gsay [TEXT]        | say [TEXT]                | guild [TEXT]"
        /call to_channel "-- tell [PLAYER][TEXT]| list memorized            | camp [desktop]"
        /call to_channel "-- camp [server]      | dohorse mount             | dohorse dismount"
        /call to_channel "-- gstatus            | gstatus on                | gstatus off"
        /call to_channel "-- gstatus VALUE      | help [command]            | ResendTells [ON]"
        /call to_channel "-- ResendTells [OFF]  | aaxp                      | xp"
        /call to_channel "-- type [command]     | reload                    | version"
        /call to_channel "-- exit               | doanchor set              | doanchor clear"
        /call to_channel "-- doanchor gohome    | cancel                    | DotAnnounce [ON][OFF]"
        /return
    }

    /if ( ${helper.Equal[target]} ) {
        /call to_channel "-- Target player           This will target a player you select, example 'target fluffy' will target the player named fluffy."
        /call to_channel "-- Target player:pet       This will target a player's pet. Example 'target fluffy:pet' will target fluffy's pet."
        /call to_channel "-- Target mypet            This will target YOUR pet. Please note it will not target the bot's pet."
        /call to_channel "-- Target pet              This will target the bot's pet."
        /return
    }

    /if ( ${helper.Equal[assist]} ) {
        /call to_channel "-- Assist player           This will assist a player you select, example 'assist fluffy' will assist the player fluffy."
        /call to_channel "-- Assist player:pet       This will assist a players pet. Example 'assist fluffy:pet' will assist fluffy's pet."
        /call to_channel "-- Assist mypet            This will assist your pet. Please note it will not assist the bots pet."
        /call to_channel "-- Assist pet              This will assist the bot's pet."
        /return
    }

    /if ( ${helper.Equal[untarget]} ) {
        /call to_channel "-- Untarget                This will clear the bot's current target."
        /return
    }

    /if ( ${helper.Equal[targethp]} ) {
        /call to_channel "-- targethp                This will have the bot report the current HP in percent of it's current target"
        /return
    }

    /if ( ${helper.Equal[mem]} ) {
        /call to_channel "-- mem set spellset        This will mem one of the bot's spellsets that is stored in thier EQ ini files. Example 'mem set death'"
        /call to_channel "-- mem list                Will list all the spells currently memorized by the bot."
        /return
    }

    /if ( ${helper.Equal[demem]} ) {
        /call to_channel "-- demem #                 This will demem the current spell in spell slot #, example 'demem 1' will unmem spell slot 1"
        /return
    }

    /if ( ${helper.Equal[pet]} ) {
        /call to_channel "-- pet attack              This will send the bot's pet into attack."
        /call to_channel "-- pet guardme             This will cause the bot's pet to guard the bot."
        /call to_channel "-- pet guardhere           This will cause the bot's pet to guard where it is."
        /call to_channel "-- pet follow              This will cause the bot's pet to follow the bot."
        /call to_channel "-- pet backoff             This will cause the bot's pet to return to the bot or guard spot."
        /call to_channel "-- pet taunton             This will cause the bot's pet to taunt while attacking."
        /call to_channel "-- pet tauntoff            This will cause the bot's pet to not taunt while attacking."
        /call to_channel "-- pet hold                This will cause the bot's pet to not attack unless told to do so. NOTE: AA Ability"
        /call to_channel "-- pet sit                 This will cause the bot's pet to sit and regen faster."
        /call to_channel "-- pet stand               This will cause the bot's pet to stand."
        /call to_channel "-- pet feign               This will cause the bot's pet to feign death."
        /call to_channel "-- pet focus               This will cause the bot's pet to focus on it's current target."
        /call to_channel "-- pet nocast              This will cause the bot's pet to not cast ANY spells."
        /return
    }

    /if ( ${helper.Equal[forage]} ) {
        /call to_channel "-- forage on               This will make the bot forage if it has the skill whenever the skill is ready."
        /call to_channel "-- forage off              This will stop the bot from foraging."
        /call to_channel "-- forage once             This will make the bot forage one time."
        /return
    }
    /if ( ${helper.Equal[hp]} ) {
        /return
    }

    /if ( ${helper.Equal[mana]} ) {
        /return
    }
    /if ( ${helper.Equal[group]} ) {
        /return
    }
    /if ( ${helper.Equal[consent]} ) {
        /return
    }
    /if ( ${helper.Equal[wherebound]} ) {
        /return
    }
    /if ( ${helper.Equal[click]} ) {
        /return
    }
    /if ( ${helper.Equal[follow]} ) {
        /return
    }
    /if ( ${helper.Equal[stopfollow]} ) {
        /return
    }
    /if ( ${helper.Equal[sit med]} ) {
        /return
    }
    /if ( ${helper.Equal[stand]} ) {
        /return
    }
    /if ( ${helper.Equal[gsay]} ) {
        /return
    }
    /if ( ${helper.Equal[say]} ) {
        /return
    }
    /if ( ${helper.Equal[guild]} ) {
        /return
    }
    /if ( ${helper.Equal[tell]} ) {
        /return
    }
    /if ( ${helper.Equal[list]} ) {
        /return
    }
    /if ( ${helper.Equal[camp]} ) {
        /return
    }
    /if ( ${helper.Equal[dohorse]} ) {
        /return
    }
    /if ( ${helper.Equal[gstatus]} ) {
        /return
    }
    /if ( ${helper.Equal[help]} ) {
        /return
    }
    /if ( ${helper.Equal[ResendTells]} ) {
        /return
    }
    /if ( ${helper.Equal[aaxp]} ) {
        /return
    }
    /if ( ${helper.Equal[xp]} ) {
        /return
    }
    /if ( ${helper.Equal[type]} ) {
        /return
    }
    /if ( ${helper.Equal[reload]} ) {
        /return
    }
    /if ( ${helper.Equal[version]} ) {
        /return
    }
    /if ( ${helper.Equal[exit]} ) {
        /return
    }
    /if ( ${helper.Equal[doanchor]} ) {
        /return
    }

    | If we get here we dont know what it is
    /call to_channel "-- Unknown HELP request ${helper}"

/return

Sub set_anchor()

    /varset mcsAnchorX ${Me.X}
    /varset mcsAnchorY ${Me.Y}
    /varset mcsFacing ${Me.Heading.DegreesCCW}
    /call to_channel "-- Home Anchor set to X: ${mcsAnchorX}, Y: ${mcsAnchorY} Facing: ${Me.Heading}"

/return

Sub clear_anchor()

    /varset mcsAnchorX NULL
    /varset mcsAnchorY NULL
    /varset mcsFacing 0
    /call to_channel "-- Home Anchor now removed"

/return

Sub go_anchor()

    /if ( ${mcsAnchorY.Equal[NULL]} || ${mcsAnchorX.Equal[NULL]} ) {
        /call to_channel "-- I dont have an anchor point, so I am not moving"
        /varset mcsAnchorRun 0
        /return
    }

    | Check for following
    /if ( ${IsFollowing.NotEqual[NULL]} ) {
        /call to_channel "-- But Master I am following you already, I cant go home!"
        /return
    }
    /call to_channel "-- Heading Home to X = ${mcsAnchorX}, Y = ${mcsAnchorY} Facing: ${mcsFacing}"

    | Face Our Location
    |/face nolook loc ${mcsAnchorY},${mcsAnchorX}
	
    | Set the Run There Command
    /varset mcsAnchorRun 1

/return

Sub LoadSpells(string Section)
    /echo LoadSpells For ${Section}

    /declare a int
	/declare b int
	/declare t0 string
	/declare t1 string
	/declare t2 string
	/declare s string
	/varset s ${Ini[${mcsINI},${Section}-Spells]}
	/if (${s.Equal[NULL]}) /return
    /for a 1 to ${Math.Calc[${s.Count["|"]} - 1]}
        /varset t0 ${Ini[${mcsINI},${Section}-Spells,${s.Arg[${a},"|"]}]}
		/varset t1 ${t0.Token[1,","]}
		/varset b  ${t0.Token[4,","]}
		/varset t2 NULL
		
		|/echo ${t1}

		/if ( ${b} > 0) {
			/if (${Me.Book[${t1} Rk. II]})	/varset t2 ${t1} Rk. II
			/if (${Me.Book[${t1} Rk. III]})	/varset t2 ${t1} Rk. III
		}
		/if ( ${b} == -2) {
			/if (${Me.CombatAbility[${t1} Rk. II]})		/varset t2 ${t1} Rk. II
			/if (${Me.CombatAbility[${t1} Rk. III]})	/varset t2 ${t1} Rk. III
		}

		/if ( ${t2.NotEqual[NULL]} ) /varset t0 ${t2}${t0.Right[ ${Math.Calc[${t0.Length} - ${t1.Length}]} ]}
        /if (${Defined[SpellInfo_${s.Arg[${a},"|"]}]}) {
            /varset SpellInfo_${s.Arg[${a},"|"]} ${t0}
        } else {
            /declare SpellInfo_${s.Arg[${a},"|"]} string outer ${t0}
        }
    /next a
    /varset SpellList ${SpellList}|${s}
/return

sub LoadCommandSet(string SetName,string Requestor)
    |/echo Commands = ${Ini[${mcsINI},${MyName}-${SetName}]}
    |/call to_channel "-- Loading command set ${SetName} for ${Requestor}"
    /declare a int
    /declare CommandSetList string ${Ini[${mcsINI},${MyName}-${SetName}]}
    /for a 1 to ${Math.Calc[${CommandSetList.Count["|"]} - 1]}
        |/echo ${Me.CleanName} "${Ini[${mcsINI},${MyName}-${SetName},${CommandSetList.Arg[${a},"|"]}]}"
		/call ProcessRequest ${Requestor} "${Ini[${mcsINI},${MyName}-${SetName},${CommandSetList.Arg[${a},"|"]}]}"
    /next a

	/if ( ${CommandSetList.NotEqual[NULL]} ) /return
	
    /varset CommandSetList string ${Ini[${mcsINI},${Me.Class.ShortName}-${SetName}]}
    /for a 1 to ${Math.Calc[${CommandSetList.Count["|"]} - 1]}
        |/echo ${Me.CleanName} "${Ini[${mcsINI},${MyName}-${SetName},${CommandSetList.Arg[${a},"|"]}]}"
		/call ProcessRequest ${Requestor} "${Ini[${mcsINI},${Me.Class.ShortName}-${SetName},${CommandSetList.Arg[${a},"|"]}]}"
    /next a
    |/call to_channel "-- Finished loading command set ${SetName}"

/return

||--------------------------------------------------------------------------------------------------------
||----
||--    MEZ / OFF TANK CODE 
||----
||--------------------------------------------------------------------------------------------------------

sub DefineMezVars
	/if ( !${Defined[AddID]} ) /declare AddID int outer 0		
	/if ( !${Defined[CheckForAddTick]} ) {
		/declare CheckForAddTick int outer 0
		/varset CheckForAddTick 6000
		/if (${Me.Class.ShortName.Equal[BRD]}) /varset CheckForAddTick 11000
		/if (${Me.Class.ShortName.Equal[ENC]}) /varset CheckForAddTick 55000

		/declare CheckForAddID1 int outer 0
		/declare CheckForAddID2 int outer 0
		/declare CheckForAddID3 int outer 0
		/declare CheckForAddID4 int outer 0
		/declare CheckForAddID5 int outer 0
		/declare CheckForAddTick1 int outer 0
		/declare CheckForAddTick2 int outer 0
		/declare CheckForAddTick3 int outer 0
		/declare CheckForAddTick4 int outer 0
		/declare CheckForAddTick5 int outer 0
		/echo ======================================= SET ASSIST ====================================
		/xtarget set 1 groupassisttarget
	}
/return

||--------------------------------------------------------------------------------------------------------
||----
||--    MEZ / OFF TANK CODE 
||----
||--------------------------------------------------------------------------------------------------------
||
|| -- MUST have extended target bar setup as follows
|| 
||  1 - Group Assist
||  2 - Group Assist's target
||
||--------------------------------------------------------------------------------------------------------

sub XXCheckForAd
	|/varset CheckForMezTimer 2s

	|/if ( ${Me.XTarget} < 2 ) /return
	|/if ( !${MobID} ) /call GuessMob
	/if ( !${Defined[CheckForAddTick]} ) /call DefineMezVars

	
	/declare i int 1
	/declare m int 0
	/declare n int 0
	/declare ID int 
	/declare WasDoingMez int 
	/varcalc WasDoingMez ${DoingMez}
	:CheckForAddLoop
    /doevents
	/varset AddID 0
	/varset n 0
	
	/varset DoingMez 0
	/for i 1 to 10
		/if (${i}<=10 && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]}) {
			/varset AddID ${Me.XTarget[${i}].ID}
		}
		/if (${i}<=10 && ${Me.XTarget[${i}].TargetType.Equal[Group Mark 2]}) {
			/varset AddID ${Me.XTarget[${i}].ID}
		}
		/if (${i}<=10 && ${Me.XTarget[${i}].TargetType.Equal[Group Mark 3]}) {
			/varset AddID ${Me.XTarget[${i}].ID}
		}

		/if (!${AddID}) {
			/varcalc n ${n}+1
			/varset AddID ${Me.NearestSpawn[${n},npc]}
			/if (${AddID} && !${Spawn[id ${AddID}].Moving}) /varset AddID 0
			/if (${AddID}) {
				|/g Mezzing Moving Mob 
				/echo AddID ${AddID} to see if its moving
			}
		}		
		
		/if ( ${AddID} && ${Spawn[${AddID}].Type.Equal[NPC]} && ${Spawn[${AddID}].Distance} < ${MezRadius}) {		
			/varset DoingMez 1
			/if (${OffTank}) {
				/target id ${AddID}
				/delay 5 ${Target.ID}==${AddID}
				/attack on
				/echo Got Add - do something - attack add.
				/delay 6s !${Target.Type.NotEqual[CORPSE]}
			} else {
				/squelch /attack off
				/squelch /stick off
				/varset dflag1 40
				/target id ${AddID}
				/delay 5 ${Target.ID}==${AddID}
				/echo MobID = ${MobID} -> Mezing ${Target.ID} = ${Target} | dflag = ${dflag1}
				|/g Mezing %t
				/varset m ${Target.Mark}
				/if ( !${m} ) {
					|/varcalc m ${i} - 2
					/if ( ${m} < 1 ) /varset m 1
					|/marknpc ${m}
				}
				/if (${Me.Class.ShortName.Equal[BRD]}) {
					|/if (${Twist.Current}!=1 && ${Twist.Current}!=10 && !${Me.GemTimer[10]}) {
					|	/squelch /twist off
					|	/squelch /twist 10
					|} else {
						/squelch /twist off
						/squelch /twist 1
					|}
					/doevents
					/delay 10
					/doevents
					/delay 10
					/doevents
					/delay 11
					/doevents					
				} else {
					/call CastSpell mez  blind
				}
			}
		}
	/next i
	
	/if (${WasDoingMez} && !${DoingMez} && ${MobID}) {
		|/g -- Done Mez -- 
		/echo Reseting MobID ${MobID}
		/varset MobID 0
	}

/return



||--------------------------------------------------------------------------------------------------------
||----
||--    MEZ / OFF TANK CODE 
||----
||--------------------------------------------------------------------------------------------------------
||----
||--    Helper Functions
||--    
||--    FindCheckForAddTick - Sets the refresh rate for tanks , bards, chanters
||--    GuessMob			- If {MobID} not set then try assisting MA for probably MobID, avoids mez on inc
||--	AssistAddID			- Assist {AddID} to figure if it has a PC targeted in which case it is hostile 
||-- 	CheckForAdd			- Main function entry point for code
|| 
||		AddID 				= ID of a npc in los 
||		AddState			= State of the npc , 0=unknown, 1=checked no target, 2=checked hostile, 3=mezed, 4=OT'ed, 9=MA target
||		AddList 			= String of mobID's format "|ID,State,TimeMez|ID2,State2,TimeMez2| ... "
||
||--------------------------------------------------------------------------------------------------------

Sub FindCheckForAddTick
	/if ( !${Defined[CheckForAddTick]} ) {
		/declare CheckForAddTick int outer 0
		/varset CheckForAddTick 6000
		/if (${Me.Class.ShortName.Equal[BRD]}) /varset CheckForAddTick 6000 
		/if (${Me.Class.ShortName.Equal[ENC]}) /varset CheckForAddTick 55000
	}
/return

sub GuessMob
	/if ( !${Defined[MobIDSet]} ) /declare MobIDSet int outer 0
	
	|/echo GuessMob called
	/varset MobIDSet 0
	/if (!${MobID} && ${GroupMA.NotEqual[NULL]} && ${Spawn[${GroupMA}].ID} && ${Spawn[${GroupMA}].Distance} < 75) {
		/varset MobID ${NetBots[${GroupMA}].TargetID}
		/if ( ${Spawn[${MobID}].Type.Equal[NPC]} ) {
			/varset MobIDSet 1
		} else /if (0) {
			/varset MobID 0
			/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist off
			/if (${Me.Class.ShortName.Equal[BRD]} && ${Medley}) /squelch /medley off			
			/squelch /stick off
			/squelch /attack off
			/target ${GroupMA}
			/delay 5 ${Target.ID} == ${Spawn[${GroupMA}].ID}
			/assist
			/delay 5 ${Target.ID} != ${Spawn[${GroupMA}].ID}
			/if ( ${Target.Type.Equal[NPC]} ) {
				/varset MobID ${Target.ID}
				/echo MA target MobID ${Target.ID} = ${Target}
				/varset MobIDSet 1
			}
		}
	} 
/return

sub AssitAddID
	/if (${Me.Class.ShortName.Equal[BRD]} && ${Twist}) /squelch /twist off
	/if (${Me.Class.ShortName.Equal[BRD]} && ${Medley}) /squelch /medley off
	/squelch /stick off
	/squelch /attack off
	/target id ${AddID}
	/delay 5 ${Target.ID}==${AddID}
	/assist
	/delay 5 ${Target.ID}!=${AddID}
/return

sub TargetAdd
	/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist off
	/if (${Me.Class.ShortName.Equal[BRD]} && ${Medley}) /squelch /medley off	
	/squelch /stick off
	/squelch /attack off
	/target id ${AddID}
	/delay 5 ${Target.ID}==${AddID}
/return





| MobID = if set is current target for group 
| AddID = if set is current Add *I* am dealing with
| AddList = String of mobID's format "|ID,State,TimeMez|ID2,State2,TimeMez2| ... "
| State: 0 = unknown | 1 = Hot Check-nothing | 2 = HoT Check-positive add tash it| 3=mez it | 4 = ot it | 9 = MT on it
sub CheckForAdd
	/if ( !${Defined[AddID]} ) /declare AddID int outer 0
	/echo CheckForAdd Tick: ${MacroQuest.Running}   MobID := ${MobID}
	/declare i int 1
	/declare j int 1
	/declare AddTM int 0
	/declare AddState int 0
	/declare MobStr string inner
	/declare TmpList string
	/declare AgroList string  ,0,1,2,3,4,5,6,7,8,9,10,11,12,42,43,44,80,129,144,
	/declare PreTargID int 0

	/if ( ${IsFollowing.NotEqual[NULL]} ) {
		/if ( ${Spawn[${IsFollowing}].Distance} > 75 ) /return
	}

	/call FindCheckForAddTick
	/varset CheckForMezTimer 1s
	
	/if (${Spawn[${Target.ID}].Type.NotEqual[CORPSE]}) /varset PreTargID ${Target.ID}

|	/echo CheckForAdd start MobList = ${MobList}
	||-- OLD WAY TO CHECK FOR ADDS VIA ANNIMATION
	/if (0) {
		:GetList
			/varset AddID ${Me.NearestSpawn[${i},npc los radius ${MezRadius}].ID}
			/if (${AddID}) {
				/if (!${MobList.Find[| ${AddID},]}) /varset MobList ${MobList} | ${AddID},0,0
				/varcalc i ${i}+1
				/goto :GetList
			}
	}
	|-- Should have list of mobs in camp
	
	|| -- NEW WAY - CHECK ONLY XTARGET AUTO HATE
	/if (1) {
		/for i 1 to 16
			/if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]}) {
				/varset AddID ${Spawn[id ${Me.XTarget[${i}].ID} radius ${MezRadius}].ID}
				/if (${AddID} && !${MobList.Find[| ${AddID},]}) /varset MobList ${MobList} | ${AddID},0,0
			}
		/next i
	}

	/if (!${MobList.Length}) /return
	
	/if (!${MobID}) /call GuessMob

	/echo Check List := ${MobList}
	
	/varset TmpList
	/varset i 1
	:CheckList
	
	/varset MobStr   ${MobList.Arg[${i},"|"]}
	/varset AddID    ${MobStr.Token[1,","]}
	|/echo Token ${i} from [ ${MobList} ] is [ ${MobStr} ]

	/if ( ${AddID} && ${Spawn[${AddID}].Type.Equal[NPC]} && ${Spawn[${AddID}].Distance} < ${MezRadius}) {
		/varset AddState  ${MobStr.Token[2,","]}
		/varset AddTM     ${MobStr.Token[3,","]}
		
		/if ( 1 && ${AddID} == ${MobID}) {
			|-- Don't need to OT or MEZ because this is the main target
			/varset  AddTM 0
			/varset  AddState 0
			/goto :EndCheckAdd
		}

		/if (${AddTM} < ${MacroQuest.Running} || ${AgroList.Find[,${Spawn[${AddID}].Animation},]} ) {
			/varcalc AddTM ${MacroQuest.Running} + 12000

			| -- AddState 0 and 1 need to check to see if its agressive
			/if ( ${AddState}==0 || ${AddState} == 1 ) { 
				/for j 1 to ${Me.XTarget}
					/if ( ${AddID} == ${Me.XTarget[${j}].ID} ) /varset AddState 2
				/next j
			}

			/if ( ${AddState} ) /call TargetAdd

			| -- Addstate 2 hostile need mez or OT once its handled move it to 3 
			/if (${AddState}==2) {
				|/echo MezImmuneList ${MezImmuneList}
				|/echo DEBUG : ( !${MezImmuneList.Find[^${Spawn[${AddID}].DisplayName}^]} ) 
				/if ( !${MezImmuneList.Find[^${Spawn[${AddID}].DisplayName}^]} ) {
					/echo AddID is Mez'able. 
					/varset AddState 3
				} else {
					/echo AddID is not Mez'able. 
				}
				|/if (${Me.Class.ShortName.Equal[ENC]})	/call CastSpell tash blind
				/if (${OffTank}) /varset AddState 4
			}

			
			|-- NEWCODE
			/if (${AddState}==3) {
				/echo Mezing ${Target.ID} = ${Target}
			    /if (!${Defined[castReturn]}) /declare castReturn string outer CAST_CANCELLED
				/varset dflag1 1200
				/call DoCastingEvents				
				/varset castReturn NULL
				/call CastSpell mez  blind
				/if (${Me.Class.ShortName.Equal[BRD]}) /delay 34
				/call DoCastingEvents				
				/echo DONE CASTING = [ ${castReturn} ]
				/if ( ${castReturn.Equal[CAST_IMMUNE]} ) {
					/varset MezImmuneList ${MezImmuneList}${Target.DisplayName}^
					/echo 	MezImmuneList updated [${MezImmuneList}]
					/ini "mcs_mez.ini"  "Immune" "${Zone.Name}" "${MezImmuneList}"
					/varset AddState 2
				} else /if ( ${castReturn.Equal[CAST_RESISTED]} ) {
					/varcalc AddTM ${MacroQuest.Running}
				} else {
					/varcalc AddTM ${MacroQuest.Running} + ${CheckForAddTick}
				}
			}

			/if (${AddState}==4) {
				/varcalc AddTM ${MacroQuest.Running} + ${CheckForAddTick}
				/attack on
				/stick 10
|				/varset MobIDSet 0
|				/delay 12s
				/varset MobID ${AddID}
				/varset CheckForMezTimer 6s
				/return
			}
		}

		:EndCheckAdd
		/varset TmpList ${TmpList} | ${AddID},${AddState},${AddTM}
	} 
	
	/if (${AddID}) {
		/varcalc i ${i}+1
		/goto :CheckList
	}
	
	|-- Should be done checking new list
	/varset MobList ${TmpList}
|	/echo MobList exiting [ ${MobList} ]

	/if (${MobIDSet}) {
		/varset MobID 0
		/varset MobIDSet 0
	}
	/if (${PreTargID} && ${Target.ID}!=${PreTargID}) {
		/target id ${PreTargID}
		/delay 5 ${Target.ID}==${PreTargID}
	}
	/if (${MobID} && ${Spawn[${MobID}].ID}) {
		/if (${Sticking})	/squelch /stick ${MeleeStick}
		/if (${InCombat})	/squelch /attack on
	}

	|/echo Exit CheckForADD  MobIDSet := ${MobIDSet}  MobID := ${MobID} 
	
/return
	
||--------------------------------------------------------------------------------------------------------
||--    MEZ / OFF TANK CODE    -- END OF CODE 
||--------------------------------------------------------------------------------------------------------




sub CheckForAddOld
    /declare CheckCount int 1
    /declare AddID int ${Me.NearestSpawn[2,npc radius ${MezRadius}].ID}
    /declare CurrentTarget int
|    /if (${MobID}) {
|        /varset CurrentTarget ${MobID}
|        /goto :StartCheck
|    }
    /varset CurrentTarget ${Me.GroupAssistTarget.ID}
    |/echo MA - ${CurrentTarget}
    /if (${CurrentTarget}) /goto :StartCheck
    /varset CurrentTarget ${Me.GroupMarkNPC[1].ID}
    |/echo Mark - ${CurrentTarget}
    /if (${CurrentTarget}) /goto :StartCheck
    /assist ${GroupMA}
    /delay 1s
    /varset CurrentTarget ${Target.ID}
    /varset MobID ${Target.ID}

    :StartCheck
    /if (${AddID} && !${LineOfSight[${Me.Y},${Me.X},${Me.Z}:${Spawn[${AddID}].Y},${Spawn[${AddID}].X},${Spawn[${AddID}].Z}]}) /return
    /if (${AddID}) {
        /echo Have add ID of ${AddID} - ${Spawn[${AddID}].CleanName} - CurrentTarget ${CurrentTarget}
        /if (${CurrentTarget}) {
            /if (${CurrentTarget} != ${AddID}) /goto :StartMez
            /echo Mez target is same as group assist, getting next nearest spawn
            |/g Mez target is same as group assist, getting next nearest spawn
            /varset AddID ${Spawn[${CurrentTarget}].NearestSpawn[npc radius 100].ID}
        }
        /goto :StartMez
    }

    /if (${CurrentTarget}) {
        /varset AddID ${Me.NearestSpawn[npc radius ${MezRadius}].ID}
        /if (${AddID} && ${AddID} != ${CurrentTarget}) {
			/if (${Spawn[${AddID}].PctHPs}<20) /return
			/goto :StartMez
		}
    }

    /return

    :StartMez
    /if (!${LineOfSight[${Me.Y},${Me.X},${Me.Z}:${Spawn[${AddID}].Y},${Spawn[${AddID}].X},${Spawn[${AddID}].Z}]}) /return
    /if (${Me.Class.ShortName.Equal[BRD]}) /call BardMez ${AddID}
    /if (${Me.Class.ShortName.Equal[ENC]}) /call EnchanterMez ${AddID}
    /if (${OffTank}) /call DoOffTanking ${AddID}
/return

|---------------------------------------------------------------
| New Check.
|---------------------------------------------------------------

sub CheckForAddNewer
	/if ( ${GetAddOff.NotEqual[NULL]}) {
		/declare CheckCount int 1
		/declare AddID int ${Me.NearestSpawn[${CheckCount},npc radius ${MezRadius}].ID}

		/echo Have someone to rescue! Tank MobID = ${MobID} Looking for adds ...

		:GetAddTarget

		/if ( ${AddID}!=${MobID} ) {
			/keypress ESC
			/target id ${AddID} 
			/delay 1s !${Target.ID}

			/echo AddID = ${Target.ID} : ${Target.Name} --> Hott : ${Me.TargetOfTarget} -> ${Me.TargetOfTarget.Name}
			/if ( ${GetAddOff.Equal[${Me.TargetOfTarget}]} ) /goto :StartMez

		}

		/varcalc CheckCount ${CheckCount} + 1
		/varset AddID ${Me.NearestSpawn[${CheckCount},npc radius ${MezRadius}].ID}
		
		/if ( ${AddID}!= 0 ) /goto :GetAddTarget
		/varset GetAddOff NULL
		/return
	}
	/return 
		
    :StartMez
	/varset GetAddOff NULL
	/varset MobID ${AddID}
	/echo Accpeting target AddID = ${Target.ID} : ${Target.Name} --> Hott : ${Me.TargetOfTarget} -> ${Me.TargetOfTarget.Name}
    /if (!${LineOfSight[${Me.Y},${Me.X},${Me.Z}:${Spawn[${AddID}].Y},${Spawn[${AddID}].X},${Spawn[${AddID}].Z}]}) /return
    /if (${Me.Class.ShortName.Equal[BRD]}) /call BardMez ${AddID}
    /if (${Me.Class.ShortName.Equal[ENC]}) /call EnchanterMez ${AddID}
    /if (${OffTank}) /call DoOffTanking ${AddID}
/return

Sub BardMez(int AddID)
    /if (!${AddID}) /return
    /varset DoingMez 1
    /squelch /twist off
    /squelch /stick off
    /squelch /attack off
    /varset Sticking 0
    /target id ${AddID}
    /delay 5
    /target id ${AddID}
    |/echo /twist ${MezSpell}
    /twist ${MezSpell}
    /call to_channel "-- Mezzing ${Target.CleanName} (${Target.ID})"
    :KeepMez
        /if (${AddID} && ${Target.ID} != ${AddID}) /target id ${AddID}
        /squelch /face fast nolook
        /delay 5
        /doevents
        /if (${Zone.Name.Equal[The Plane of Knowledge]} || ${Zone.Name.Equal[Nexus]} || ${Zone.Name.Equal[Guild Lobby]} ) {
            /varset AddID 0
            /varset DoingMez 0
            /varset MezBroke 0
            /squelch /twist off
            /return
        }
        /if (!${Target.ID} || ${Target.ID} == ${MobID} || ${Target.ID} == ${Me.GroupAssistTarget.ID} || ${Target.ID} ==  ${Me.GroupMarkNPC[1].ID} || ${MezBroke}) {
            /varset AddID 0
            /varset DoingMez 0
            /varset MezBroke 0
            /twist off
            /if (${DownTimeTwist.NotEqual[NULL]}) /squelch /mcs twist ${DownTimeTwist}
            /return
        }
    /goto :KeepMez
/return

sub EnchanterMez(int AddID)
    /if (!${AddID}) /return
    /declare MezDuration int
    /declare NeedRune int
    /varset DoingMez 1
    /squelch /stick off
    /squelch /attack off
    /varset Sticking 0
    /target id ${AddID}
    /delay 5
    /target id ${AddID}
    /call to_channel "-- Mezzing ${Target.CleanName} (${Target.ID})"
    /if (${Defined[SpellInfo_tash]}) /call Cast "${SpellInfo_tash.Token[1,","]}"

    /declare MezTime timer 3s
    /varset MezDuration ${Math.Calc[${Spell[${SpellInfo_${MezSpell}.Token[1,","]}].Duration} * 6 - 8]}s
    /echo Duration ${SpellDuration} - ${Math.Calc[${Spell[${SpellInfo_${MezSpell}.Token[1,","]}].Duration} * 6 - 8]}s
    /face fast nolook
    /call Cast "${SpellInfo_${MezSpell}.Token[1,","]}" gem"${SpellInfo_${MezSpell}.Token[4,","]}"
    /if ( ${Macro.Return.NotEqual[CAST_SUCCESS]} ) {
        /varset MezTime 3s
    } else {
        /varset MezTime ${MezDuration}s
    }

    /squelch /face fast nolook
    :KeepMez
        /if (${AddID} && ${Target.ID} != ${AddID}) /target id ${AddID}
        /delay 1s
        /if (${Me.AltAbility[Eldritch Rune]} > 0 && ${Me.AltAbilityReady[Eldritch Rune]} && ${Me.PctHPs} < 50) {
            /alt activate 173
        }
        |/echo Animation is ${Target.Animation}
        /if ( ${Target.Animation} == 32 || ${Target.Animation} == 110 || ${Target.Animation} == 111 || ${Target.Animation} == 26  ) {
            |/echo Add is mezzed
        } else {
            /if (${Target.ID}) /varset MezTime 0
        }
        /if (${MezTime} <=0 && ${Target.ID} ) {
            /face fast nolook
            /call Cast "${SpellInfo_${MezSpell}.Token[1,","]}" gem"${SpellInfo_${MezSpell}.Token[4,","]}"
            /delay 3
            /if (${Me.AltAbility[Eldritch Rune]} > 0 && ${Me.AltAbilityReady[Eldritch Rune]} && ${Me.PctHPs} < 50) {
                /alt activate 173
            }
            /delay 3
            /if (${Me.AltAbility[Eldritch Rune]} > 0 && ${Me.AltAbilityReady[Eldritch Rune]} && ${Me.PctHPs} < 50) {
                /alt activate 173
            }
            /delay 3
            /if (${Me.AltAbility[Eldritch Rune]} > 0 && ${Me.AltAbilityReady[Eldritch Rune]} && ${Me.PctHPs} < 50) {
                /alt activate 173
            }
            /delay 3
            /if ( ${Target.Animation} == 32 || ${Target.Animation} == 110 || ${Target.Animation} == 111 || ${Target.Animation} == 26 ) {
                /echo Add is mezzed
            } else {
                /echo Add not mezzed yet, trying again...
                /varset NeedRune 1
                /if (${Me.Buff[Arcane Rune].ID}) /varset NeedRune 0
                /if (${Me.Buff[Ethereal Rune].ID}) /varset NeedRune 0
                /if (${Me.Buff[Eldritch Rune].ID}) /varset NeedRune 0

                /if (${NeedRune}) {
                    /if (${Me.AltAbility[Eldritch Rune]} > 0 && ${Me.AltAbilityReady[Eldritch Rune]} && ${Me.PctHPs} < 50) {
                        /alt activate 173
                    } else {
                        /if (${MezTime} > 180) {
                            /call CastSpell rune blind
                        }
                    }
                }
                /if (!${Target.ID} || ${Target.ID} == ${MobID} || ${Target.ID} == ${Me.GroupAssistTarget.ID} || ${Target.ID} ==  ${Me.GroupMarkNPC[1].ID} || ${MezBroke}) {
                    /varset AddID 0
                    /varset DoingMez 0
                    /varset MezBroke 0
                    /varset MezTime 0
                    /call CastSpell rune blind
                    /return
                }

                /if (${Target.ID}) /varset MezTime 0
                /goto :KeepMez
            }
            /varset MezTime ${MezDuration}s
            |/echo MezTimer ${MezTime}
        }

        /varset NeedRune 1
        /if (${Me.Buff[Arcane Rune].ID}) /varset NeedRune 0
        /if (${Me.Buff[Ethereal Rune].ID}) /varset NeedRune 0
        /if (${Me.Buff[Eldritch Rune].ID}) /varset NeedRune 0

        /if (${NeedRune}) {
            /if (${Me.AltAbility[Eldritch Rune]} > 0 && ${Me.AltAbilityReady[Eldritch Rune]} && ${Me.PctHPs} < 50) {
                /alt activate 173
            } else {
                /if (${MezTime} > 180) {
                    /call CastSpell rune blind
                }
            }
        }

        /delay 2
        /doevents
        /if (${Zone.Name.Equal[The Plane of Knowledge]} || ${Zone.Name.Equal[Nexus]} || ${Zone.Name.Equal[The Guild Lobby]} ) {
            /varset AddID 0
            /varset DoingMez 0
            /varset MezBroke 0
            /return
        }
        /if (!${Target.ID} || ${Target.ID} == ${MobID} || ${Target.ID} == ${Me.GroupAssistTarget.ID} || ${Target.ID} ==  ${Me.GroupMarkNPC[1].ID} || ${MezBroke}) {
            /varset AddID 0
            /varset DoingMez 0
            /varset MezBroke 0
            /varset MezTime 0
            /call CastSpell rune blind
            /return
        }
    /goto :KeepMez
/return



Sub DoOffTanking(int AddID)
    /if (!${AddID}) /return
    /varset DoingMez 1
    /squelch /twist off
    /squelch /stick off
    /squelch /attack off
    /varset Sticking 0
    /target id ${AddID}
    /delay 5
    /target id ${AddID}

    /call LoadCommandSet "offtank-on"

    /call to_channel "-- OffTanking ${Target.CleanName} (${Target.ID})"
    :KeepTanking
        /if (${AddID} && ${Target.ID} != ${AddID}) /target id ${AddID}
        /squelch /face fast nolook
        /delay 5
        /doevents
        /if (!${Target.ID} || ${Target.ID} == ${MobID} || ${Target.ID} == ${Me.GroupAssistTarget.ID} || ${Target.ID} ==  ${Me.GroupMarkNPC[1].ID}) {
            /varset AddID 0
            /varset DoingMez 0
            /varset MezBroke 0
            /call LoadCommandSet "offtank-off"
            /return
        }
    /goto :KeepTanking
/return


sub TakeRez
    /if (${Window[ConfirmationDialogBox].Open}) {
		/echo TakRez starting. 
		/notify ConfirmationDialogBox Yes_Button leftmouseup
		/delay 2s
		/if (${Zone.ID}==213) /if (${Window[RespawnWnd].Open}) /nomodkey /notify RespawnWnd RW_OptionsList listselect 1
		/if (${Zone.ID}!=213) /if (${Window[RespawnWnd].Open}) /nomodkey /notify RespawnWnd RW_OptionsList listselect 2
		/delay 1s
		/nomodkey /notify RespawnWnd RW_SelectButton leftmouseup
		/delay 3s 
	}
/return

sub LootTarget
    /declare a int 1
    /declare t int 0
    /declare loottotal int
    /declare lootslot int
    /declare lootleft int 0
    /declare LootTimeout timer 1m

    /loot
	
	|| --- ELH: Add Lootall for own corpse 
|	/if (${Target.CleanName.Equal[${Me}'s corpse]}) {
|        /delay 8s
|		/echo Try using loot all button
|		/notify LootWnd LootAllButton leftmouseup		
|		/delay 4s
|		/echo Hopefully all looted.
|	}


    |/delay 5s ${Me.State.Equal[BIND]}
    |/if (${Me.State.NotEqual[BIND]}) /return

    /delay 2s

	/echo Are we done looting? Items left = ${Corpse.Items}
    /if (${Corpse.Items} <= 0) /goto :DoneLooting

    /varset loottotal 0
    :LootLag
    /if (${loottotal}!=${Corpse.Items}) {
	    /varset loottotal ${Corpse.Items}
        /delay 1s
        /if (${LootTimeout} <= 0) {
            /call to_channel "-- Problem looting, it's taking too long. Aborted."
            /keypress ESC
            /keypress ESC
            /keypress ESC
            /return
        }
        /goto :LootLag
    }
    /if (${loottotal}<=${lootleft}) /goto :LootLag


    /varset loottotal ${Math.Calc[${Corpse.Items}-${lootleft}]}
    /for lootslot 1 to ${loottotal}
    :LootItem
		/echo Inside LootItem, 
        /if (${LootTimeout} <= 0) {
            /call to_channel "-- Problem looting, it's taking too long. Aborted."
            /keypress ESC
            /keypress ESC
            /keypress ESC
            /return
        }
	/varset LoreItemError 0
    /shiftkey /itemnotify loot${lootslot} rightmouseup
    /delay 5 !${Corpse.Item[${lootslot}].ID}
	/doevents
    /if (!${Corpse.Item[${lootslot}].ID} || ${LoreItemError}) {
        /next lootslot
    } else /goto :LootItem


		
	
	
    /if (${Math.Calc[${Corpse.Items}-${lootleft}]}>0) /goto :LootLag
    :DoneLooting
    /notify LootWnd DoneButton leftmouseup
    /delay 2s

	/echo Exiting LootItem sub. 
/return


sub SpreadOut

    |/declare tMoveBack int ${Math.Rand[${MoveBack}]}
    |/declare tMoveSide int ${Math.Rand[${MoveSide}]}
    |/declare tMoveDir int ${Math.Rand[${MoveDir}]}

    |/echo tMoveBack ${tMoveBack}
    |/echo tMoveSide ${tMoveSide}
    |/echo tMoveDir ${tMoveDir}
    /declare WasSitting int 0
    /if ( !${Me.Standing} ) {
        /varset WasSitting 1
        /stand
    }

    /keypress back hold
    /delay ${MoveBack}
    /keypress back

    /if (${MoveDir}>0) {
        /keypress strafe_right hold
    } else {
        /keypress strafe_left hold
    }
    /delay ${MoveSide}
    /keypress strafe_right
    /keypress strafe_left
    /if (${WasSitting}) /sit
/return


sub LootNPC
    /if (${Me.UseAdvancedLooting}) {
		/call UseAdvLoot
		/return
	}
	/echo LootNPC
	/varset Looting TRUE
	/call LootMobs
	/varset Looting FALSE
	/echo LootNPC - DONE
	/return
/declare MoveDelay int local
/declare LootSlot int local 1
/declare LootTimeout timer 20s

/keypress ESC

:Top

    /squelch /target npc corpse
    /delay 2
    /if (!${Target.ID}) /return
        /if (${Target.Distance} < 15) {
                 /face fast nolook
        } else /if (${Target.Distance}>=15 && ${Target.Distance}<120) {
            /face fast nolook
            /keypress forward hold
            /varset MoveDelay ${Math.Calc[(${Target.Distance})/4.3]}
            /keypress forward hold
            /delay ${MoveDelay}
            /keypress forward
            /if (${LootTimeout} <= 0) {
                /call to_channel "-- Problem looting, it's taking too long. Aborted."
                /keypress ESC
                /return
            }
            /goto :Top
         } else {
             /echo Corpse is too far away
             /keypress ESC
             /return
       }

    :LootWnd
        /loot
        /if (${LootTimeout} <= 0) {
            /call to_channel "-- Problem looting, it's taking too long. Aborted."
            /keypress ESC
            /return
        }
        /delay 1
        /if (!${Target.ID}) /return
        /if (!${Window[LootWnd].Open}) /goto :LootWnd

    :lootloop
        /if (${LootTimeout} <= 0) {
            /call to_channel "-- Problem looting, it's taking too long. Aborted."
            /keypress ESC
            /return
        }
        /if (!${Target.ID}) /return
        /if (${Me.State.Equal["STAND"]}) /goto :doneloot
        /if (${Corpse.Items}==0) /goto :doneloot
        /if (${LootSlot}>=32) /goto :doneloot

        :Loot
            /itemnotify Loot${LootSlot} leftmouseup
            /delay 1s
			/cursor check
            /autoinventory
            /delay 2

            /varcalc LootSlot ${LootSlot}+1
            /goto :lootloop
        :doneloot

   /notify LootWnd DoneButton leftmouseup
   /varset LootSlot 0

/return

Sub JoinIRC

   /if (${IRCChannel.Left[1].NotEqual[#]}) {
      /echo Channel name needs to start with a #
      /return
   }

   /squelch /i quit
   /delay 3s
   /squelch /iconnect ${IRCServer} ${IRCPort} ${IRCChannel} ${Me.Name}
   /delay 3s
   /squelch /i join ${IRCChannel}


/return

Sub Event_OtherQuitIRC(string Line, string User)

    /if (${WatchIRC} && ${WatchIRCName.Equal[${User}]} && ${WatchIRCIM.NotEqual[IM]}) {
        /im msg ${WatchIRCIM} ${Time} -- ${Me.Name} saw ${User} leave IRC
    }
    /if (${WatchIRC} && ${WatchIRCName.Equal[${User}]} && ${WatchIRCIM2.NotEqual[IM]}) {
        /im msg ${WatchIRCIM2} ${Time} -- ${Me.Name} saw ${User} leave IRC
    }

/return


|===================================================|
|                                                   |
|Simple moving and object-avoidance routines        |
|                                                   |
|Originally by beatnik007 (Who credits Mckorr)      |
|                                                   |
|Revised and converted to MQ2Data by Terramantian   |
|===================================================|
| Sub MoveToLoc                                     |
|===================================================|
|This simply moves the player to within 10 units of |
|the requested location, while avoiding obstacles   |
|                                                   |
|This is beatnik007's original sub, with a few minor|
|changes and rewritten in MQ2Data format            |
|                                                   |
|SYNTAX: /call MoveToLoc Y X                        |
|===================================================|

Sub MoveToLoc(MoveToY, MoveToX)
    |/echo Moving to Location: ${MoveToY}, ${MoveToX}.
    |/echo Distance: ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}

    /declare running int
    /declare thisZone int ${Zone.ID}
    /declare distanceNow float
    /declare distanceBefore float
    /declare distanceModifier int
	/declare distanceAbort int 1
    /varset running 0
    /declare distanceTimer timer 15
    /varset distanceBefore ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}
    /varset distanceModifier 1

    :moveToLocation
    /doevents

    /if (${Zone.ID} != ${thisZone}) {
        /keypress forward
        /keypress back
        /return
    }

    /if ( ${mcsAnchorRun} && (${mcsAnchorY.Equal[NULL]} || ${mcsAnchorX.Equal[NULL]} )) {
        /echo -- Something up, run set but no anchor locs -- aborting
        /keypress forward
        /return
    }


    /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}<10) {
        /keypress forward
        /return
    }
    /face fast nolook loc ${MoveToY},${MoveToX}

    /if (${distanceTimer}==0) {
        /if (${Me.Sneaking}) {
            /varset distanceModifier 2
        } else {
            /varset distanceModifier 1
        }

        /varset distanceNow ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}
        /if (${Math.Calc[${distanceBefore}-${distanceNow}]}<${Math.Calc[10/${distanceModifier}]}) {
            /call strafePastObstacle
			/varcalc distanceAbort ${distanceAbort}+1
			/if (${distanceAbort}>3) /return
        }
        /varset distanceBefore ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}
        /varset distanceTimer 15
    }

    /if (${running}==0) {
        /keypress forward
        /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}>10) {
            /varset running 1
            /keypress forward hold
        }
    } else {
        /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}<11) {
            /varset running 0
            /keypress forward
        }
    }
    /goto :moveToLocation
/return


sub strafePastObstacle
    /keypress forward
    /keypress back hold
    /delay 2
    /keypress back
    /if (${Math.Rand[99]}>50) {
        /keypress strafe_right hold
    } else {
        /keypress strafe_left hold
    }
    /delay 3
    /keypress strafe_right
    /keypress strafe_left
    /keypress forward hold
/return

Sub MoveToSpawn(MoveToID, StopDistance)

    /if (!(${Defined[MoveToID]})||(${Spawn[MoveToID].ID})) {
        /echo Spawn ID not found or no ID provided. Aborting...
        /return
    }
    /if (!(${Defined[StopDistance]})) {
   /echo Stopping point not defined, using default distance of 70
        /declare StopDistance int local
        /varset StopDistance 70
    }

    |/echo Moving to Spawn: ${MoveToID} (${Spawn[${MoveToID}].CleanName}).
    |/echo Current Location: ${Spawn[${MoveToID}].Y}, ${Spawn[${MoveToID}].X}
    |/echo Current Distance: ${Spawn[${MoveToID}].Distance}

    /declare thisZone int ${Zone.ID}
    /declare running int local
    /declare distanceNow float local
    /declare distanceBefore float local
    /declare distanceModifier int local
    /varset running 0
    /declare distanceTimer timer 15
    /varset distanceBefore ${Spawn[${MoveToID}].Distance}
    /varset distanceModifier 1

    :moveToSpawn

    /squelch /face fast nolook id ${MoveToID}

    /if (${Zone.ID} != ${thisZone}) {
        /keypress forward
        /return
    }

    /if (${Spawn[${MoveToID}].Distance}<${StopDistance}) {
        /keypress forward
        /return
    }

    /if (${distanceTimer}==0) {
        /if (${Me.Sneaking}) {
            /varset distanceModifier 2
        } else {
            /varset distanceModifier 1
        }

        /varset distanceNow ${Spawn[${MoveToID}].Distance}
        /if (${Math.Calc[${distanceBefore}-${distanceNow}]}<${Math.Calc[10/${distanceModifier}]}) {
      /call strafePastObstacle
        }
        /varset distanceBefore ${Spawn[${MoveToID}].Distance}
        /varset distanceTimer 15
    }

    /if (${running}==0) {
        /keypress forward
        /if (${Spawn[${MoveToID}].Distance}>=${StopDistance}) {
            /varset running 1
            /keypress forward hold
        }
    } else {
        /if (${Spawn[${MoveToID}].Distance}<${StopDistance}) {
            /varset running 0
            /keypress forward
        }
    }
    /goto :moveToSpawn
/return

| Only to be used by the previous functions - It's obvious what it does. |


Sub MoveToLocD(MoveToY, MoveToX, StopDistance)
    |/echo Moving to Location: ${MoveToY}, ${MoveToX}.
    |/echo Distance: ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}

    /declare thisZone int ${Zone.ID}
    /declare running int local
    /declare distanceNow float local
    /declare distanceBefore float local
    /declare distanceModifier int local
    /varset running 0
    /declare distanceTimer timer 15
    /varset distanceBefore ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}
    /varset distanceModifier 1


    :moveToLocation

    /face fast nolook loc ${MoveToY},${MoveToX}

    /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}<10) {
        /keypress forward
        /return
    }

    /if (${Zone.ID} != ${thisZone}) {
        /keypress forward
        /return
    }

    /if (${distanceTimer}==0) {
        /if (${Me.Sneaking}) {
            /varset distanceModifier 2
        } else {
            /varset distanceModifier 1
        }

        /varset distanceNow ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}
        /if (${Math.Calc[${distanceBefore}-${distanceNow}]}<${Math.Calc[10/${distanceModifier}]}) {
      /call strafePastObstacle
        }
        /varset distanceBefore ${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}
        /varset distanceTimer 15
    }

    /if (${running}==0) {
        /keypress forward
        /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}>=${StopDistance}) {
            /varset running 1
            /keypress forward hold
        }
    } else {
        /if (${Math.Distance[${Me.Y},${Me.X}:${MoveToY},${MoveToX}]}<${StopDistance}) {
            /varset running 0
            /keypress forward
        }
    }
    /goto :moveToLocation
/return


Sub ItemToCursor(string itemName)
   /declare oldSlotID int local
   /declare i int local

   /varset oldSlotID ${FindItem[${itemName}].InvSlot.ID} | oldSlotID = slot the item was originally in

   /echo ItemToCursor ${itemName}

   /if ( !${oldSlotID} ) {
      /echo Could not find item ${itemName}
      /return
   }
:auto_inv
   /if ( ${Cursor.ID} && !${Cursor.Name.Equal[${itemName}]} ) {
      /if ( ${Cursor.Container} ) {
         /for i 1 to 8
            /if ( !${InvSlot[pack${i}].Item.Container} ) {
               /nomodkey /itemnotify pack${i} leftmouseup
            }
         /next i
      } else {
         /autoinventory
      }
      /goto :auto_inv
   }


:pick_up_item
 | if the item is in a bag and it's not open, then open it!
   /if ( ${InvSlot[${oldSlotID}].Pack} && !${Window[${InvSlot[${oldSlotID}].Pack.Name}].Open} ) /nomodkey /itemnotify ${InvSlot[${oldSlotID}].Pack} rightmouseup
	/delay 5

 | ok.. pick up the item now!
   /squelch /nomodkey /shiftkey /itemnotify ${InvSlot[${oldSlotID}]} leftmouseup
   /delay 5

 | if item isn't on your cursor, try again!
|   /if ( !${Cursor.Name.Equal[${itemName}]} ) {
|      /if ( ${Cursor.ID} && !${Cursor.Container} ) /autoinventory
|      /goto :pick_up_item
|   }
:close_pack
   /if ( ${InvSlot[${oldSlotID}].Pack} && ${Window[${InvSlot[${oldSlotID}].Pack.Name}].Open} && ( ${Cursor.Name.Equal[${itemName}]} || ${FindItem[${itemName}].ID} ) ) {
      /squelch /nomodkey /itemnotify ${InvSlot[${oldSlotID}].Pack} rightmouseup
      /goto :close_pack
   }
/return


Sub Event_Locked
	/declare TryLock timer int 0

	/if (!${Cursor.ID} && ${TryLock}==0 && ${FindItem[Lockpicks].InvSlot.ID}) {
		/varset TryLock 6s
		/call ItemToCursor Lockpicks
        /keypress use hold
        /keypress use
		/autoinventory
	}

/return


